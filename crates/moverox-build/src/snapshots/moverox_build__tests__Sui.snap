---
source: crates/moverox-build/src/tests.rs
expression: sui_framework
---
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod accumulator {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator)]
    #[allow(non_snake_case)]
    pub struct AccumulatorRoot {
        pub id: super::object::UID,
    }
    impl AccumulatorRoot {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self { id }
        }
    }
    impl ::moverox::traits::HasKey for AccumulatorRoot {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(not(doctest), doc = " Storage for 128-bit accumulator values.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Currently only used to represent the sum of 64 bit values (such as `Balance<T>`)."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The additional bits are necessary to prevent overflow, as it would take 2^64 deposits of U64_MAX"
    )]
    #[cfg_attr(not(doctest), doc = " to cause an overflow.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator)]
    #[allow(non_snake_case)]
    pub struct U128 {
        pub value: u128,
    }
    impl U128 {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u128) -> Self {
            Self { value }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " `Key` is used only for computing the field id of accumulator objects."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `T` is the type of the accumulated value, e.g. `Balance<SUI>`"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator)]
    #[allow(non_snake_case)]
    pub struct Key<T> {
        pub address: address,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Key<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(address: address) -> Self {
            Self {
                address,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod accumulator_metadata {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " === Accumulator metadata ===")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Metadata system has been removed, but structs must remain for backwards compatibility."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator_metadata)]
    #[allow(non_snake_case)]
    pub struct OwnerKey {
        pub owner: address,
    }
    impl OwnerKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(owner: address) -> Self {
            Self { owner }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " An owner field, to which all AccumulatorMetadata fields for the owner are"
    )]
    #[cfg_attr(not(doctest), doc = " attached.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator_metadata)]
    #[allow(non_snake_case)]
    pub struct Owner {
        /// The individual balances owned by the owner.
        pub balances: super::bag::Bag,
        pub owner: address,
    }
    impl Owner {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(balances: super::bag::Bag, owner: address) -> Self {
            Self { balances, owner }
        }
    }
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator_metadata)]
    #[allow(non_snake_case)]
    pub struct MetadataKey<T>(bool, #[serde(skip)] ::std::marker::PhantomData<T>);
    impl<T> MetadataKey<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false, ::std::marker::PhantomData)
        }
    }
    #[cfg_attr(not(doctest), doc = " A metadata field for a balance field with type T.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator_metadata)]
    #[allow(non_snake_case)]
    pub struct Metadata<T> {
        /// Any per-balance fields we wish to add in the future.
        pub fields: super::bag::Bag,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Metadata<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(fields: super::bag::Bag) -> Self {
            Self {
                fields,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(not(doctest), doc = " === Accumulator object count storage ===")]
    #[cfg_attr(
        not(doctest),
        doc = " Key for storing the net count of accumulator objects as a dynamic field on the accumulator root."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator_metadata)]
    #[allow(non_snake_case)]
    pub struct AccumulatorObjectCountKey(bool);
    impl AccumulatorObjectCountKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod accumulator_settlement {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator_settlement)]
    #[allow(non_snake_case)]
    pub struct EventStreamHead {
        /// Merkle Mountain Range of all events in the stream.
        pub mmr: vector<u256>,
        /// Checkpoint sequence number at which the event stream was written.
        pub checkpoint_seq: u64,
        /// Number of events in the stream.
        pub num_events: u64,
    }
    impl EventStreamHead {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            mmr: vector<u256>,
            checkpoint_seq: u64,
            num_events: u64,
        ) -> Self {
            Self {
                mmr,
                checkpoint_seq,
                num_events,
            }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod address_alias {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Singleton shared object which manages creation of AddressAliases state."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The actual alias configs are created as derived objects with this object"
    )]
    #[cfg_attr(not(doctest), doc = " as the parent.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = address_alias)]
    #[allow(non_snake_case)]
    pub struct AddressAliasState {
        pub id: super::object::UID,
        pub version: u64,
    }
    impl AddressAliasState {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, version: u64) -> Self {
            Self { id, version }
        }
    }
    impl ::moverox::traits::HasKey for AddressAliasState {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Tracks the set of addresses allowed to act as a given sender."
    )]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " An alias allows transactions signed by the alias address to act as the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " original address. For example, if address X sets an alias of address Y, then"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " then a transaction signed by Y can set its sender address to X."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = address_alias)]
    #[allow(non_snake_case)]
    pub struct AddressAliases {
        pub id: super::object::UID,
        pub aliases: super::vec_set::VecSet<address>,
    }
    impl AddressAliases {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            aliases: super::vec_set::VecSet<address>,
        ) -> Self {
            Self { id, aliases }
        }
    }
    impl ::moverox::traits::HasKey for AddressAliases {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Internal key used for derivation of AddressAliases object addresses."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = address_alias)]
    #[allow(non_snake_case)]
    pub struct AliasKey(pub address);
    impl AliasKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: address) -> Self {
            Self(_0)
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod authenticator_state {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Singleton shared object which stores the global authenticator state."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The actual state is stored in a dynamic field of type AuthenticatorStateInner to support"
    )]
    #[cfg_attr(not(doctest), doc = " future versions of the authenticator state.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct AuthenticatorState {
        pub id: super::object::UID,
        pub version: u64,
    }
    impl AuthenticatorState {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, version: u64) -> Self {
            Self { id, version }
        }
    }
    impl ::moverox::traits::HasKey for AuthenticatorState {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct AuthenticatorStateInner {
        pub version: u64,
        /// List of currently active JWKs.
        pub active_jwks: vector<ActiveJwk>,
    }
    impl AuthenticatorStateInner {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(version: u64, active_jwks: vector<ActiveJwk>) -> Self {
            Self { version, active_jwks }
        }
    }
    #[cfg_attr(not(doctest), doc = " Must match the JWK struct in fastcrypto-zkp")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct JWK {
        pub kty: ::moverox_sui::std::string::String,
        pub e: ::moverox_sui::std::string::String,
        pub n: ::moverox_sui::std::string::String,
        pub alg: ::moverox_sui::std::string::String,
    }
    impl JWK {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            kty: ::moverox_sui::std::string::String,
            e: ::moverox_sui::std::string::String,
            n: ::moverox_sui::std::string::String,
            alg: ::moverox_sui::std::string::String,
        ) -> Self {
            Self { kty, e, n, alg }
        }
    }
    #[cfg_attr(not(doctest), doc = " Must match the JwkId struct in fastcrypto-zkp")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct JwkId {
        pub iss: ::moverox_sui::std::string::String,
        pub kid: ::moverox_sui::std::string::String,
    }
    impl JwkId {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            iss: ::moverox_sui::std::string::String,
            kid: ::moverox_sui::std::string::String,
        ) -> Self {
            Self { iss, kid }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct ActiveJwk {
        pub jwk_id: JwkId,
        pub jwk: JWK,
        pub epoch: u64,
    }
    impl ActiveJwk {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(jwk_id: JwkId, jwk: JWK, epoch: u64) -> Self {
            Self { jwk_id, jwk, epoch }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A bag is a heterogeneous map-like collection. The collection is similar to `sui::table` in that"
)]
#[cfg_attr(
    not(doctest),
    doc = " its keys and values are not stored within the `Bag` value, but instead are stored using Sui's"
)]
#[cfg_attr(
    not(doctest),
    doc = " object system. The `Bag` struct acts only as a handle into the object system to retrieve those"
)]
#[cfg_attr(not(doctest), doc = " keys and values.")]
#[cfg_attr(
    not(doctest),
    doc = " Note that this means that `Bag` values with exactly the same key-value mapping will not be"
)]
#[cfg_attr(not(doctest), doc = " equal, with `==`, at runtime. For example")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = " let bag1 = bag::new();")]
#[cfg_attr(not(doctest), doc = " let bag2 = bag::new();")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag1, 0, false);")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag1, 1, true);")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag2, 0, false);")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag2, 1, true);")]
#[cfg_attr(
    not(doctest),
    doc = " // bag1 does not equal bag2, despite having the same entries"
)]
#[cfg_attr(not(doctest), doc = " assert!(&bag1 != &bag2);")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(
    not(doctest),
    doc = " At it's core, `sui::bag` is a wrapper around `UID` that allows for access to"
)]
#[cfg_attr(
    not(doctest),
    doc = " `sui::dynamic_field` while preventing accidentally stranding field values. A `UID` can be"
)]
#[cfg_attr(
    not(doctest),
    doc = " deleted, even if it has dynamic fields associated with it, but a bag, on the other hand, must be"
)]
#[cfg_attr(not(doctest), doc = " empty to be destroyed.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod bag {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bag)]
    #[allow(non_snake_case)]
    pub struct Bag {
        /// the ID of this bag
        pub id: super::object::UID,
        /// the number of key-value pairs in the bag
        pub size: u64,
    }
    impl Bag {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self { id, size }
        }
    }
    impl ::moverox::traits::HasKey for Bag {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A storable handler for Balances in general. Is used in the `Coin`"
)]
#[cfg_attr(
    not(doctest),
    doc = " module to allow balance operations and can be used to implement"
)]
#[cfg_attr(not(doctest), doc = " custom coins with `Supply` and `Balance`s.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod balance {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " A Supply of T. Used for minting and burning.")]
    #[cfg_attr(
        not(doctest),
        doc = " Wrapped into a `TreasuryCap` in the `Coin` module."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = balance)]
    #[allow(non_snake_case)]
    pub struct Supply<T> {
        pub value: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Supply<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u64) -> Self {
            Self {
                value,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Storable balance - an inner struct of a Coin type."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Can be used to store coins which don't need the key ability."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = balance)]
    #[allow(non_snake_case)]
    pub struct Balance<T> {
        pub value: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Balance<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u64) -> Self {
            Self {
                value,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(not(doctest), doc = " This module implements BCS (de)serialization in Move.")]
#[cfg_attr(
    not(doctest),
    doc = " Full specification can be found here: https://github.com/diem/bcs"
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " Short summary (for Move-supported types):")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " - address - sequence of X bytes")]
#[cfg_attr(not(doctest), doc = " - bool - byte with 0 or 1")]
#[cfg_attr(not(doctest), doc = " - u8 - a single u8 byte")]
#[cfg_attr(not(doctest), doc = " - u16 / u32 / u64 / u128 / u256 - LE bytes")]
#[cfg_attr(not(doctest), doc = " - vector - ULEB128 length + LEN elements")]
#[cfg_attr(
    not(doctest),
    doc = " - option - first byte bool: None (0) or Some (1), then value"
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " Usage example:")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(
    not(doctest),
    doc = " /// This function reads u8 and u64 value from the input"
)]
#[cfg_attr(not(doctest), doc = " /// and returns the rest of the bytes.")]
#[cfg_attr(
    not(doctest),
    doc = " fun deserialize(bytes: vector<u8>): (u8, u64, vector<u8>) {"
)]
#[cfg_attr(not(doctest), doc = "     use sui::bcs::{Self, BCS};")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = "     let prepared: BCS = bcs::new(bytes);")]
#[cfg_attr(not(doctest), doc = "     let (u8_value, u64_value) = (")]
#[cfg_attr(not(doctest), doc = "         prepared.peel_u8(),")]
#[cfg_attr(not(doctest), doc = "         prepared.peel_u64()")]
#[cfg_attr(not(doctest), doc = "     );")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = "     // unpack bcs struct")]
#[cfg_attr(not(doctest), doc = "     let leftovers = prepared.into_remainder_bytes();")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = "     (u8_value, u64_value, leftovers)")]
#[cfg_attr(not(doctest), doc = " }")]
#[cfg_attr(not(doctest), doc = " ```")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod bcs {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A helper struct that saves resources on operations. For better"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " vector performance, it stores reversed bytes of the BCS and"
    )]
    #[cfg_attr(not(doctest), doc = " enables use of `vector::pop_back`.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bcs)]
    #[allow(non_snake_case)]
    pub struct BCS {
        pub bytes: vector<u8>,
    }
    impl BCS {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self { bytes }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A simple library that enables hot-potato-locked borrow mechanics."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " With Programmable transactions, it is possible to borrow a value within"
)]
#[cfg_attr(
    not(doctest),
    doc = " a transaction, use it and put back in the end. Hot-potato `Borrow` makes"
)]
#[cfg_attr(
    not(doctest),
    doc = " sure the object is returned and was not swapped for another one."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod borrow {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " An object wrapping a `T` and providing the borrow API."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Referent<T> {
        pub id: address,
        pub value: Option<T>,
    }
    impl<T> Referent<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: address, value: Option<T>) -> Self {
            Self { id, value }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A hot potato making sure the object is put back once borrowed."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Borrow {
        pub r#ref: address,
        pub obj: super::object::ID,
    }
    impl Borrow {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(r#ref: address, obj: super::object::ID) -> Self {
            Self { r#ref, obj }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Test {
        pub id: super::object::UID,
    }
    impl Test {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self { id }
        }
    }
    impl ::moverox::traits::HasKey for Test {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " APIs for accessing time from move calls, via the `Clock`: a unique"
)]
#[cfg_attr(not(doctest), doc = " shared object that is created at 0x6 during genesis.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod clock {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Singleton shared object that exposes time to Move calls.  This"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " object is found at address 0x6, and can only be read (accessed"
    )]
    #[cfg_attr(not(doctest), doc = " via an immutable reference) by entry functions.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Entry Functions that attempt to accept `Clock` by mutable"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " reference or value will fail to verify, and honest validators"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " will not sign or execute transactions that use `Clock` as an"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " input parameter, unless it is passed by immutable reference."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = clock)]
    #[allow(non_snake_case)]
    pub struct Clock {
        pub id: super::object::UID,
        /// The clock's timestamp, which is set automatically by a
        /// system transaction every time consensus commits a
        /// schedule, or by `sui::clock::increment_for_testing` during
        /// testing.
        pub timestamp_ms: u64,
    }
    impl Clock {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, timestamp_ms: u64) -> Self {
            Self { id, timestamp_ms }
        }
    }
    impl ::moverox::traits::HasKey for Clock {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines the `Coin` type - platform wide representation of fungible"
)]
#[cfg_attr(
    not(doctest),
    doc = " tokens and coins. `Coin` can be described as a secure wrapper around"
)]
#[cfg_attr(not(doctest), doc = " `Balance` type.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod coin {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A coin of type `T` worth `value`. Transferable and storable"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct Coin<T> {
        pub id: super::object::UID,
        pub balance: super::balance::Balance<T>,
    }
    impl<T> Coin<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            balance: super::balance::Balance<T>,
        ) -> Self {
            Self { id, balance }
        }
    }
    impl<T> ::moverox::traits::HasKey for Coin<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Each Coin type T created through `create_currency` function will have a"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " unique instance of CoinMetadata<T> that stores the metadata for this coin type."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct CoinMetadata<T> {
        pub id: super::object::UID,
        /// Number of decimal places the coin uses.
        /// A coin with `value ` N and `decimals` D should be shown as N / 10^D
        /// E.g., a coin with `value` 7002 and decimals 3 should be displayed as 7.002
        /// This is metadata for display usage only.
        pub decimals: u8,
        /// Name for the token
        pub name: ::moverox_sui::std::string::String,
        /// Symbol for the token
        pub symbol: ::moverox_sui::std::ascii::String,
        /// Description of the token
        pub description: ::moverox_sui::std::string::String,
        /// URL for the token logo
        pub icon_url: Option<super::url::Url>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> CoinMetadata<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            decimals: u8,
            name: ::moverox_sui::std::string::String,
            symbol: ::moverox_sui::std::ascii::String,
            description: ::moverox_sui::std::string::String,
            icon_url: Option<super::url::Url>,
        ) -> Self {
            Self {
                id,
                decimals,
                name,
                symbol,
                description,
                icon_url,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for CoinMetadata<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Similar to CoinMetadata, but created only for regulated coins that use the DenyList."
    )]
    #[cfg_attr(not(doctest), doc = " This object is always immutable.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct RegulatedCoinMetadata<T> {
        pub id: super::object::UID,
        /// The ID of the coin's CoinMetadata object.
        pub coin_metadata_object: super::object::ID,
        /// The ID of the coin's DenyCap object.
        pub deny_cap_object: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> RegulatedCoinMetadata<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            coin_metadata_object: super::object::ID,
            deny_cap_object: super::object::ID,
        ) -> Self {
            Self {
                id,
                coin_metadata_object,
                deny_cap_object,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for RegulatedCoinMetadata<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(not(doctest), doc = " Capability allowing the bearer to mint and burn")]
    #[cfg_attr(not(doctest), doc = " coins of type `T`. Transferable")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct TreasuryCap<T> {
        pub id: super::object::UID,
        pub total_supply: super::balance::Supply<T>,
    }
    impl<T> TreasuryCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            total_supply: super::balance::Supply<T>,
        ) -> Self {
            Self { id, total_supply }
        }
    }
    impl<T> ::moverox::traits::HasKey for TreasuryCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Capability allowing the bearer to deny addresses from using the currency's coins--"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " immediately preventing those addresses from interacting with the coin as an input to a"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " transaction and at the start of the next preventing them from receiving the coin."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " If `allow_global_pause` is true, the bearer can enable a global pause that behaves as if"
    )]
    #[cfg_attr(not(doctest), doc = " all addresses were added to the deny list.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct DenyCapV2<T> {
        pub id: super::object::UID,
        pub allow_global_pause: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DenyCapV2<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, allow_global_pause: bool) -> Self {
            Self {
                id,
                allow_global_pause,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for DenyCapV2<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct CurrencyCreated<T> {
        pub decimals: u8,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> CurrencyCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(decimals: u8) -> Self {
            Self {
                decimals,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Capability allowing the bearer to freeze addresses, preventing those addresses from"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " interacting with the coin as an input to a transaction."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct DenyCap<T> {
        pub id: super::object::UID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DenyCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for DenyCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod config {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct Config<WriteCap> {
        pub id: super::object::UID,
        #[serde(skip)]
        _WriteCap: ::std::marker::PhantomData<WriteCap>,
    }
    impl<WriteCap> Config<WriteCap> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self {
                id,
                _WriteCap: ::std::marker::PhantomData,
            }
        }
    }
    impl<WriteCap> ::moverox::traits::HasKey for Config<WriteCap> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct Setting<Value> {
        pub data: Option<SettingData<Value>>,
    }
    impl<Value> Setting<Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(data: Option<SettingData<Value>>) -> Self {
            Self { data }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct SettingData<Value> {
        pub newer_value_epoch: u64,
        pub newer_value: Option<Value>,
        pub older_value_opt: Option<Value>,
    }
    impl<Value> SettingData<Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            newer_value_epoch: u64,
            newer_value: Option<Value>,
            older_value_opt: Option<Value>,
        ) -> Self {
            Self {
                newer_value_epoch,
                newer_value,
                older_value_opt,
            }
        }
    }
}
#[cfg_attr(not(doctest), doc = " Group operations of BLS12-381.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod bls12381 {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bls12381)]
    #[allow(non_snake_case)]
    pub struct Scalar {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl Scalar {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bls12381)]
    #[allow(non_snake_case)]
    pub struct G1 {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl G1 {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bls12381)]
    #[allow(non_snake_case)]
    pub struct G2 {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl G2 {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bls12381)]
    #[allow(non_snake_case)]
    pub struct GT {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl GT {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bls12381)]
    #[allow(non_snake_case)]
    pub struct UncompressedG1 {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl UncompressedG1 {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod ecdsa_k1 {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = ecdsa_k1)]
    #[allow(non_snake_case)]
    pub struct KeyPair {
        pub private_key: vector<u8>,
        pub public_key: vector<u8>,
    }
    impl KeyPair {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(private_key: vector<u8>, public_key: vector<u8>) -> Self {
            Self { private_key, public_key }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod groth16 {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Represents an elliptic curve construction to be used in the verifier. Currently we support BLS12-381 and BN254."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This should be given as the first parameter to `prepare_verifying_key` or `verify_groth16_proof`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = groth16)]
    #[allow(non_snake_case)]
    pub struct Curve {
        pub id: u8,
    }
    impl Curve {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: u8) -> Self {
            Self { id }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A `PreparedVerifyingKey` consisting of four components in serialized form."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = groth16)]
    #[allow(non_snake_case)]
    pub struct PreparedVerifyingKey {
        pub vk_gamma_abc_g1_bytes: vector<u8>,
        pub alpha_g1_beta_g2_bytes: vector<u8>,
        pub gamma_g2_neg_pc_bytes: vector<u8>,
        pub delta_g2_neg_pc_bytes: vector<u8>,
    }
    impl PreparedVerifyingKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            vk_gamma_abc_g1_bytes: vector<u8>,
            alpha_g1_beta_g2_bytes: vector<u8>,
            gamma_g2_neg_pc_bytes: vector<u8>,
            delta_g2_neg_pc_bytes: vector<u8>,
        ) -> Self {
            Self {
                vk_gamma_abc_g1_bytes,
                alpha_g1_beta_g2_bytes,
                gamma_g2_neg_pc_bytes,
                delta_g2_neg_pc_bytes,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A `PublicProofInputs` wrapper around its serialized bytes."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = groth16)]
    #[allow(non_snake_case)]
    pub struct PublicProofInputs {
        pub bytes: vector<u8>,
    }
    impl PublicProofInputs {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self { bytes }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A `ProofPoints` wrapper around the serialized form of three proof points."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = groth16)]
    #[allow(non_snake_case)]
    pub struct ProofPoints {
        pub bytes: vector<u8>,
    }
    impl ProofPoints {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self { bytes }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Generic Move and native functions for group operations."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod group_ops {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = group_ops)]
    #[allow(non_snake_case)]
    pub struct Element<T> {
        pub bytes: vector<u8>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Element<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self {
                bytes,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod nitro_attestation {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " Represents a PCR entry with an index and value.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = nitro_attestation)]
    #[allow(non_snake_case)]
    pub struct PCREntry {
        pub index: u8,
        pub value: vector<u8>,
    }
    impl PCREntry {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(index: u8, value: vector<u8>) -> Self {
            Self { index, value }
        }
    }
    #[cfg_attr(not(doctest), doc = " Nitro Attestation Document defined for AWS.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = nitro_attestation)]
    #[allow(non_snake_case)]
    pub struct NitroAttestationDocument {
        /// Issuing Nitro hypervisor module ID.
        pub module_id: vector<u8>,
        /// UTC time when document was created, in milliseconds since UNIX epoch.
        pub timestamp: u64,
        /// The digest function used for calculating the register values.
        pub digest: vector<u8>,
        /// A list of PCREntry containing the index and the PCR bytes.
        /// <https://docs.aws.amazon.com/enclaves/latest/user/set-up-attestation.html#where>.
        pub pcrs: vector<PCREntry>,
        /// An optional DER-encoded key the attestation, consumer can use to encrypt data with.
        pub public_key: Option<vector<u8>>,
        /// Additional signed user data, defined by protocol.
        pub user_data: Option<vector<u8>>,
        /// An optional cryptographic nonce provided by the attestation consumer as a proof of
        /// authenticity.
        pub nonce: Option<vector<u8>>,
    }
    impl NitroAttestationDocument {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            module_id: vector<u8>,
            timestamp: u64,
            digest: vector<u8>,
            pcrs: vector<PCREntry>,
            public_key: Option<vector<u8>>,
            user_data: Option<vector<u8>>,
            nonce: Option<vector<u8>>,
        ) -> Self {
            Self {
                module_id,
                timestamp,
                digest,
                pcrs,
                public_key,
                user_data,
                nonce,
            }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod zklogin_verified_id {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Possession of a VerifiedID proves that the user's address was created using zklogin and the given parameters."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = zklogin_verified_id)]
    #[allow(non_snake_case)]
    pub struct VerifiedID {
        /// The ID of this VerifiedID
        pub id: super::object::UID,
        /// The address this VerifiedID is associated with
        pub owner: address,
        /// The name of the key claim
        pub key_claim_name: ::moverox_sui::std::string::String,
        /// The value of the key claim
        pub key_claim_value: ::moverox_sui::std::string::String,
        /// The issuer
        pub issuer: ::moverox_sui::std::string::String,
        /// The audience (wallet)
        pub audience: ::moverox_sui::std::string::String,
    }
    impl VerifiedID {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            owner: address,
            key_claim_name: ::moverox_sui::std::string::String,
            key_claim_value: ::moverox_sui::std::string::String,
            issuer: ::moverox_sui::std::string::String,
            audience: ::moverox_sui::std::string::String,
        ) -> Self {
            Self {
                id,
                owner,
                key_claim_name,
                key_claim_value,
                issuer,
                audience,
            }
        }
    }
    impl ::moverox::traits::HasKey for VerifiedID {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod zklogin_verified_issuer {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Possession of a VerifiedIssuer proves that the user's address was created using zklogin and with the given issuer"
    )]
    #[cfg_attr(not(doctest), doc = " (identity provider).")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = zklogin_verified_issuer)]
    #[allow(non_snake_case)]
    pub struct VerifiedIssuer {
        /// The ID of this VerifiedIssuer
        pub id: super::object::UID,
        /// The address this VerifiedID is associated with
        pub owner: address,
        /// The issuer
        pub issuer: ::moverox_sui::std::string::String,
    }
    impl VerifiedIssuer {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            owner: address,
            issuer: ::moverox_sui::std::string::String,
        ) -> Self {
            Self { id, owner, issuer }
        }
    }
    impl ::moverox::traits::HasKey for VerifiedIssuer {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines the `DenyList` type. The `DenyList` shared object is used to restrict access to"
)]
#[cfg_attr(
    not(doctest),
    doc = " instances of certain core types from being used as inputs by specified addresses in the deny"
)]
#[cfg_attr(not(doctest), doc = " list.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod deny_list {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A shared object that stores the addresses that are blocked for a given core type."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct DenyList {
        pub id: super::object::UID,
        /// The individual deny lists.
        pub lists: super::bag::Bag,
    }
    impl DenyList {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, lists: super::bag::Bag) -> Self {
            Self { id, lists }
        }
    }
    impl ::moverox::traits::HasKey for DenyList {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The capability used to write to the deny list config. Ensures that the Configs for the"
    )]
    #[cfg_attr(not(doctest), doc = " DenyList are modified only by this module.")]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct ConfigWriteCap(bool);
    impl ConfigWriteCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The dynamic object field key used to store the `Config` for a given type, essentially a"
    )]
    #[cfg_attr(not(doctest), doc = " `(per_type_index, per_type_key)` pair.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct ConfigKey {
        pub per_type_index: u64,
        pub per_type_key: vector<u8>,
    }
    impl ConfigKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(per_type_index: u64, per_type_key: vector<u8>) -> Self {
            Self {
                per_type_index,
                per_type_key,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The setting key used to store the deny list for a given address in the `Config`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct AddressKey(pub address);
    impl AddressKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: address) -> Self {
            Self(_0)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The setting key used to store the global pause setting in the `Config`."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct GlobalPauseKey(bool);
    impl GlobalPauseKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The event emitted when a new `Config` is created for a given type. This can be useful for"
    )]
    #[cfg_attr(not(doctest), doc = " tracking the `ID` of a type's `Config` object.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct PerTypeConfigCreated {
        pub key: ConfigKey,
        pub config_id: super::object::ID,
    }
    impl PerTypeConfigCreated {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(key: ConfigKey, config_id: super::object::ID) -> Self {
            Self { key, config_id }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Stores the addresses that are denied for a given core type."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct PerTypeList {
        pub id: super::object::UID,
        /// Number of object types that have been banned for a given address.
        /// Used to quickly skip checks for most addresses.
        pub denied_count: super::table::Table<address, u64>,
        /// Set of addresses that are banned for a given type.
        /// For example with `sui::coin::Coin`: If addresses A and B are banned from using
        /// "0...0123::my_coin::MY_COIN", this will be "0...0123::my_coin::MY_COIN" -> {A, B}.
        pub denied_addresses: super::table::Table<
            vector<u8>,
            super::vec_set::VecSet<address>,
        >,
    }
    impl PerTypeList {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            denied_count: super::table::Table<address, u64>,
            denied_addresses: super::table::Table<
                vector<u8>,
                super::vec_set::VecSet<address>,
            >,
        ) -> Self {
            Self {
                id,
                denied_count,
                denied_addresses,
            }
        }
    }
    impl ::moverox::traits::HasKey for PerTypeList {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Enables the creation of objects with deterministic addresses derived from a parent object's UID."
)]
#[cfg_attr(
    not(doctest),
    doc = " This module provides a way to generate objects with predictable addresses based on a parent UID"
)]
#[cfg_attr(
    not(doctest),
    doc = " and a key, creating a namespace that ensures uniqueness for each parent-key combination,"
)]
#[cfg_attr(not(doctest), doc = " which is usually how registries are built.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " Key features:")]
#[cfg_attr(
    not(doctest),
    doc = " - Deterministic address generation based on parent object UID and key"
)]
#[cfg_attr(
    not(doctest),
    doc = " - Derived objects can exist and operate independently of their parent"
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " The derived UIDs, once created, are independent and do not require sequencing on the parent"
)]
#[cfg_attr(
    not(doctest),
    doc = " object. They can be used without affecting the parent. The parent only maintains a record of"
)]
#[cfg_attr(
    not(doctest),
    doc = " which derived addresses have been claimed to prevent duplicates."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod derived_object {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Added as a DF to the parent's UID, to mark an ID as claimed."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = derived_object)]
    #[allow(non_snake_case)]
    pub struct Claimed(pub super::object::ID);
    impl Claimed {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: super::object::ID) -> Self {
            Self(_0)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " An internal key to protect from generating the same UID twice (e.g. collide with DFs)"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = derived_object)]
    #[allow(non_snake_case)]
    pub struct DerivedObjectKey<K>(pub K);
    impl<K> DerivedObjectKey<K> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: K) -> Self {
            Self(_0)
        }
    }
    #[cfg_attr(not(doctest), doc = " The possible values of a claimed UID.")]
    #[cfg_attr(
        not(doctest),
        doc = " We make it an enum to make upgradeability easier in the future."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = derived_object)]
    #[allow(non_snake_case)]
    pub enum ClaimedStatus {
        /// The UID has been claimed and cannot be re-claimed or used.
        Reserved,
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines a Display struct which defines the way an Object"
)]
#[cfg_attr(
    not(doctest),
    doc = " should be displayed. The intention is to keep data as independent"
)]
#[cfg_attr(
    not(doctest),
    doc = " from its display as possible, protecting the development process"
)]
#[cfg_attr(
    not(doctest),
    doc = " and keeping it separate from the ecosystem agreements."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " Each of the fields of the Display object should allow for pattern"
)]
#[cfg_attr(
    not(doctest),
    doc = " substitution and filling-in the pieces using the data from the object T."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " More entry functions might be added in the future depending on the use cases."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod display {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " The Display<T> object. Defines the way a T instance should be"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " displayed. Display object can only be created and modified with"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " a PublisherCap, making sure that the rules are set by the owner"
    )]
    #[cfg_attr(not(doctest), doc = " of the type.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Each of the display properties should support patterns outside"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " of the system, making it simpler to customize Display based"
    )]
    #[cfg_attr(not(doctest), doc = " on the property values of an Object.")]
    #[cfg_attr(not(doctest), doc = " ```")]
    #[cfg_attr(not(doctest), doc = " // Example of a display object")]
    #[cfg_attr(not(doctest), doc = " Display<0x...::capy::Capy> {")]
    #[cfg_attr(not(doctest), doc = "  fields:")]
    #[cfg_attr(not(doctest), doc = "    <name, \"Capy { genes }\">")]
    #[cfg_attr(not(doctest), doc = "    <link, \"https://capy.art/capy/{ id }\">")]
    #[cfg_attr(
        not(doctest),
        doc = "    <image, \"https://api.capy.art/capy/{ id }/svg\">"
    )]
    #[cfg_attr(not(doctest), doc = "    <description, \"Lovely Capy, one of many\">")]
    #[cfg_attr(not(doctest), doc = " }")]
    #[cfg_attr(not(doctest), doc = " ```")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Uses only String type due to external-facing nature of the object,"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the property names have a priority over their types."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct Display<T> {
        pub id: super::object::UID,
        /// Contains fields for display. Currently supported
        /// fields are: name, link, image and description.
        pub fields: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            ::moverox_sui::std::string::String,
        >,
        /// Version that can only be updated manually by the Publisher.
        pub version: u16,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Display<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            fields: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                ::moverox_sui::std::string::String,
            >,
            version: u16,
        ) -> Self {
            Self {
                id,
                fields,
                version,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for Display<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Event: emitted when a new Display object has been created for type T."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Type signature of the event corresponds to the type while id serves for"
    )]
    #[cfg_attr(not(doctest), doc = " the discovery.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Since Sui RPC supports querying events by type, finding a Display for the T"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " would be as simple as looking for the first event with `Display<T>`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct DisplayCreated<T> {
        pub id: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DisplayCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(not(doctest), doc = " Version of Display got updated -")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct VersionUpdated<T> {
        pub id: super::object::ID,
        pub version: u16,
        pub fields: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            ::moverox_sui::std::string::String,
        >,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> VersionUpdated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::ID,
            version: u16,
            fields: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                ::moverox_sui::std::string::String,
            >,
        ) -> Self {
            Self {
                id,
                version,
                fields,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " In addition to the fields declared in its type definition, a Sui object can have dynamic fields"
)]
#[cfg_attr(
    not(doctest),
    doc = " that can be added after the object has been constructed. Unlike ordinary field names"
)]
#[cfg_attr(
    not(doctest),
    doc = " (which are always statically declared identifiers) a dynamic field name can be any value with"
)]
#[cfg_attr(
    not(doctest),
    doc = " the `copy`, `drop`, and `store` abilities, e.g. an integer, a boolean, or a string."
)]
#[cfg_attr(
    not(doctest),
    doc = " This gives Sui programmers the flexibility to extend objects on-the-fly, and it also serves as a"
)]
#[cfg_attr(not(doctest), doc = " building block for core collection types")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod dynamic_field {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Internal object used for storing the field and value"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = dynamic_field)]
    #[allow(non_snake_case)]
    pub struct Field<Name, Value> {
        /// Determined by the hash of the object ID, the field name value and it's type,
        /// i.e. hash(parent.id || name || Name)
        pub id: super::object::UID,
        /// The value for the name of this field
        pub name: Name,
        /// The value bound to this field
        pub value: Value,
    }
    impl<Name, Value> Field<Name, Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, name: Name, value: Value) -> Self {
            Self { id, name, value }
        }
    }
    impl<Name, Value> ::moverox::traits::HasKey for Field<Name, Value> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::dynamic_field`, this module allows for the access of dynamic fields. But"
)]
#[cfg_attr(
    not(doctest),
    doc = " unlike, `sui::dynamic_field` the values bound to these dynamic fields _must_ be objects"
)]
#[cfg_attr(
    not(doctest),
    doc = " themselves. This allows for the objects to still exist within in storage, which may be important"
)]
#[cfg_attr(
    not(doctest),
    doc = " for external tools. The difference is otherwise not observable from within Move."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod dynamic_object_field {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = dynamic_object_field)]
    #[allow(non_snake_case)]
    pub struct Wrapper<Name> {
        pub name: Name,
    }
    impl<Name> Wrapper<Name> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(name: Name) -> Self {
            Self { name }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A module for accumulating funds, i.e. Balance-like types."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod funds_accumulator {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Allows for withdrawing funds from a given address. The `Withdrawal` can be created in PTBs for"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the transaction sender, or dynamically from an object via `withdraw_from_object`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The redemption of the funds must be initiated from the module that defines `T`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = funds_accumulator)]
    #[allow(non_snake_case)]
    pub struct Withdrawal<T> {
        /// The owner of the funds, either an object or a transaction sender
        pub owner: address,
        /// At signing we check the limit <= balance when taking this as a call arg.
        /// If this was generated from an object, we cannot check this until redemption.
        pub limit: u256,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Withdrawal<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(owner: address, limit: u256) -> Self {
            Self {
                owner,
                limit,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Kiosk is a primitive for building safe, decentralized and trustless trading"
)]
#[cfg_attr(
    not(doctest),
    doc = " experiences. It allows storing and trading any types of assets as long as"
)]
#[cfg_attr(
    not(doctest),
    doc = " the creator of these assets implements a `TransferPolicy` for them."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ### Principles and philosophy:")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - Kiosk provides guarantees of \"true ownership\"; - just like single owner"
)]
#[cfg_attr(
    not(doctest),
    doc = " objects, assets stored in the Kiosk can only be managed by the Kiosk owner."
)]
#[cfg_attr(
    not(doctest),
    doc = " Only the owner can `place`, `take`, `list`, perform any other actions on"
)]
#[cfg_attr(not(doctest), doc = " assets in the Kiosk.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - Kiosk aims to be generic - allowing for a small set of default behaviors"
)]
#[cfg_attr(
    not(doctest),
    doc = " and not imposing any restrictions on how the assets can be traded. The only"
)]
#[cfg_attr(
    not(doctest),
    doc = " default scenario is a `list` + `purchase` flow; any other trading logic can"
)]
#[cfg_attr(
    not(doctest),
    doc = " be implemented on top using the `list_with_purchase_cap` (and a matching"
)]
#[cfg_attr(not(doctest), doc = " `purchase_with_cap`) flow.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - For every transaction happening with a third party a `TransferRequest` is"
)]
#[cfg_attr(
    not(doctest),
    doc = " created - this way creators are fully in control of the trading experience."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ### Asset states in the Kiosk:")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - `placed` -  An asset is `place`d into the Kiosk and can be `take`n out by"
)]
#[cfg_attr(
    not(doctest),
    doc = " the Kiosk owner; it's freely tradable and modifiable via the `borrow_mut`"
)]
#[cfg_attr(not(doctest), doc = " and `borrow_val` functions.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - `locked` - Similar to `placed` except that `take` is disabled and the only"
)]
#[cfg_attr(
    not(doctest),
    doc = " way to move the asset out of the Kiosk is to `list` it or"
)]
#[cfg_attr(
    not(doctest),
    doc = " `list_with_purchase_cap` therefore performing a trade (issuing a"
)]
#[cfg_attr(
    not(doctest),
    doc = " `TransferRequest`). The check on the `lock` function makes sure that the"
)]
#[cfg_attr(
    not(doctest),
    doc = " `TransferPolicy` exists to not lock the item in a `Kiosk` forever."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - `listed` - A `place`d or a `lock`ed item can be `list`ed for a fixed price"
)]
#[cfg_attr(
    not(doctest),
    doc = " allowing anyone to `purchase` it from the Kiosk. While listed, an item can"
)]
#[cfg_attr(
    not(doctest),
    doc = " not be taken or modified. However, an immutable borrow via `borrow` call is"
)]
#[cfg_attr(
    not(doctest),
    doc = " still available. The `delist` function returns the asset to the previous"
)]
#[cfg_attr(not(doctest), doc = " state.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - `listed_exclusively` - An item is listed via the `list_with_purchase_cap`"
)]
#[cfg_attr(
    not(doctest),
    doc = " function (and a `PurchaseCap` is created). While listed this way, an item"
)]
#[cfg_attr(
    not(doctest),
    doc = " can not be `delist`-ed unless a `PurchaseCap` is returned. All actions"
)]
#[cfg_attr(not(doctest), doc = " available at this item state require a `PurchaseCap`:")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " 1. `purchase_with_cap` - to purchase the item for a price equal or higher"
)]
#[cfg_attr(not(doctest), doc = " than the `min_price` set in the `PurchaseCap`.")]
#[cfg_attr(
    not(doctest),
    doc = " 2. `return_purchase_cap` - to return the `PurchaseCap` and return the asset"
)]
#[cfg_attr(not(doctest), doc = " into the previous state.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " When an item is listed exclusively it cannot be modified nor taken and"
)]
#[cfg_attr(
    not(doctest),
    doc = " losing a `PurchaseCap` would lock the item in the Kiosk forever. Therefore,"
)]
#[cfg_attr(
    not(doctest),
    doc = " it is recommended to only use `PurchaseCap` functionality in trusted"
)]
#[cfg_attr(
    not(doctest),
    doc = " applications and not use it for direct trading (eg sending to another"
)]
#[cfg_attr(not(doctest), doc = " account).")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " ### Using multiple Transfer Policies for different \"tracks\":"
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " Every `purchase` or `purchase_with_purchase_cap` creates a `TransferRequest`"
)]
#[cfg_attr(
    not(doctest),
    doc = " hot potato which must be resolved in a matching `TransferPolicy` for the"
)]
#[cfg_attr(
    not(doctest),
    doc = " transaction to pass. While the default scenario implies that there should be"
)]
#[cfg_attr(
    not(doctest),
    doc = " a single `TransferPolicy<T>` for `T`; it is possible to have multiple, each"
)]
#[cfg_attr(not(doctest), doc = " one having its own set of rules.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ### Examples:")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - I create one `TransferPolicy` with \"Royalty Rule\" for everyone"
)]
#[cfg_attr(
    not(doctest),
    doc = " - I create a special `TransferPolicy` for bearers of a \"Club Membership\""
)]
#[cfg_attr(not(doctest), doc = " object so they don't have to pay anything")]
#[cfg_attr(
    not(doctest),
    doc = " - I create and wrap a `TransferPolicy` so that players of my game can"
)]
#[cfg_attr(
    not(doctest),
    doc = " transfer items between `Kiosk`s in game without any charge (and maybe not"
)]
#[cfg_attr(not(doctest), doc = " even paying the price with a 0 SUI PurchaseCap)")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = " Kiosk -> (Item, TransferRequest)")]
#[cfg_attr(not(doctest), doc = " ... TransferRequest ------> Common Transfer Policy")]
#[cfg_attr(
    not(doctest),
    doc = " ... TransferRequest ------> In-game Wrapped Transfer Policy"
)]
#[cfg_attr(
    not(doctest),
    doc = " ... TransferRequest ------> Club Membership Transfer Policy"
)]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " See `transfer_policy` module for more details on how they function."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod kiosk {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " An object which allows selling collectibles within \"kiosk\" ecosystem."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " By default gives the functionality to list an item openly - for anyone"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " to purchase providing the guarantees for creators that every transfer"
    )]
    #[cfg_attr(not(doctest), doc = " needs to be approved via the `TransferPolicy`.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct Kiosk {
        pub id: super::object::UID,
        /// Balance of the Kiosk - all profits from sales go here.
        pub profits: super::balance::Balance<super::sui::SUI>,
        /// Always point to `sender` of the transaction.
        /// Can be changed by calling `set_owner` with Cap.
        pub owner: address,
        /// Number of items stored in a Kiosk. Used to allow unpacking
        /// an empty Kiosk if it was wrapped or has a single owner.
        pub item_count: u32,
        /// [DEPRECATED] Please, don't use the `allow_extensions` and the matching
        /// `set_allow_extensions` function - it is a legacy feature that is being
        /// replaced by the `kiosk_extension` module and its Extensions API.
        ///
        /// Exposes `uid_mut` publicly when set to `true`, set to `false` by default.
        pub allow_extensions: bool,
    }
    impl Kiosk {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            profits: super::balance::Balance<super::sui::SUI>,
            owner: address,
            item_count: u32,
            allow_extensions: bool,
        ) -> Self {
            Self {
                id,
                profits,
                owner,
                item_count,
                allow_extensions,
            }
        }
    }
    impl ::moverox::traits::HasKey for Kiosk {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A Capability granting the bearer a right to `place` and `take` items"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " from the `Kiosk` as well as to `list` them and `list_with_purchase_cap`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct KioskOwnerCap {
        pub id: super::object::UID,
        pub r#for: super::object::ID,
    }
    impl KioskOwnerCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, r#for: super::object::ID) -> Self {
            Self { id, r#for }
        }
    }
    impl ::moverox::traits::HasKey for KioskOwnerCap {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A capability which locks an item and gives a permission to"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " purchase it from a `Kiosk` for any price no less than `min_price`."
    )]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Allows exclusive listing: only bearer of the `PurchaseCap` can"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " purchase the asset. However, the capability should be used"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " carefully as losing it would lock the asset in the `Kiosk`."
    )]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " The main application for the `PurchaseCap` is building extensions"
    )]
    #[cfg_attr(not(doctest), doc = " on top of the `Kiosk`.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct PurchaseCap<T> {
        pub id: super::object::UID,
        /// ID of the `Kiosk` the cap belongs to.
        pub kiosk_id: super::object::ID,
        /// ID of the listed item.
        pub item_id: super::object::ID,
        /// Minimum price for which the item can be purchased.
        pub min_price: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> PurchaseCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            kiosk_id: super::object::ID,
            item_id: super::object::ID,
            min_price: u64,
        ) -> Self {
            Self {
                id,
                kiosk_id,
                item_id,
                min_price,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for PurchaseCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Hot potato to ensure an item was returned after being taken using"
    )]
    #[cfg_attr(not(doctest), doc = " the `borrow_val` call.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct Borrow {
        pub kiosk_id: super::object::ID,
        pub item_id: super::object::ID,
    }
    impl Borrow {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            kiosk_id: super::object::ID,
            item_id: super::object::ID,
        ) -> Self {
            Self { kiosk_id, item_id }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Dynamic field key for an item placed into the kiosk."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct Item {
        pub id: super::object::ID,
    }
    impl Item {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self { id }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Dynamic field key for an active offer to purchase the T. If an"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " item is listed without a `PurchaseCap`, exclusive is set to `false`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct Listing {
        pub id: super::object::ID,
        pub is_exclusive: bool,
    }
    impl Listing {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID, is_exclusive: bool) -> Self {
            Self { id, is_exclusive }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Dynamic field key which marks that an item is locked in the `Kiosk` and"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " can't be `take`n. The item then can only be listed / sold via the PurchaseCap."
    )]
    #[cfg_attr(not(doctest), doc = " Lock is released on `purchase`.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct Lock {
        pub id: super::object::ID,
    }
    impl Lock {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self { id }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Emitted when an item was listed by the safe owner. Can be used"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " to track available offers anywhere on the network; the event is"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " type-indexed which allows for searching for offers of a specific `T`"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct ItemListed<T> {
        pub kiosk: super::object::ID,
        pub id: super::object::ID,
        pub price: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> ItemListed<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            kiosk: super::object::ID,
            id: super::object::ID,
            price: u64,
        ) -> Self {
            Self {
                kiosk,
                id,
                price,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Emitted when an item was purchased from the `Kiosk`. Can be used"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " to track finalized sales across the network. The event is emitted"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " in both cases: when an item is purchased via the `PurchaseCap` or"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " when it's purchased directly (via `list` + `purchase`)."
    )]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " The `price` is also emitted and might differ from the `price` set"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " in the `ItemListed` event. This is because the `PurchaseCap` only"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " sets a minimum price for the item, and the actual price is defined"
    )]
    #[cfg_attr(not(doctest), doc = " by the trading module / extension.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct ItemPurchased<T> {
        pub kiosk: super::object::ID,
        pub id: super::object::ID,
        pub price: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> ItemPurchased<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            kiosk: super::object::ID,
            id: super::object::ID,
            price: u64,
        ) -> Self {
            Self {
                kiosk,
                id,
                price,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Emitted when an item was delisted by the safe owner. Can be used"
    )]
    #[cfg_attr(not(doctest), doc = " to close tracked offers.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk)]
    #[allow(non_snake_case)]
    pub struct ItemDelisted<T> {
        pub kiosk: super::object::ID,
        pub id: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> ItemDelisted<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(kiosk: super::object::ID, id: super::object::ID) -> Self {
            Self {
                kiosk,
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " This module implements the Kiosk Extensions functionality. It allows"
)]
#[cfg_attr(
    not(doctest),
    doc = " exposing previously protected (only-owner) methods to third-party apps."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " A Kiosk Extension is a module that implements any functionality on top of"
)]
#[cfg_attr(
    not(doctest),
    doc = " the `Kiosk` without discarding nor blocking the base. Given that `Kiosk`"
)]
#[cfg_attr(
    not(doctest),
    doc = " itself is a trading primitive, most of the extensions are expected to be"
)]
#[cfg_attr(
    not(doctest),
    doc = " related to trading. However, there's no limit to what can be built using the"
)]
#[cfg_attr(
    not(doctest),
    doc = " `kiosk_extension` module, as it gives certain benefits such as using `Kiosk`"
)]
#[cfg_attr(not(doctest), doc = " as the storage for any type of data / assets.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ### Flow:")]
#[cfg_attr(
    not(doctest),
    doc = " - An extension can only be installed by the Kiosk Owner and requires an"
)]
#[cfg_attr(not(doctest), doc = " authorization via the `KioskOwnerCap`.")]
#[cfg_attr(
    not(doctest),
    doc = " - When installed, the extension is given a permission bitmap that allows it"
)]
#[cfg_attr(
    not(doctest),
    doc = " to perform certain protected actions (eg `place`, `lock`). However, it is"
)]
#[cfg_attr(
    not(doctest),
    doc = " possible to install an extension that does not have any permissions."
)]
#[cfg_attr(
    not(doctest),
    doc = " - Kiosk Owner can `disable` the extension at any time, which prevents it"
)]
#[cfg_attr(
    not(doctest),
    doc = " from performing any protected actions. The storage is still available to the"
)]
#[cfg_attr(not(doctest), doc = " extension until it is completely removed.")]
#[cfg_attr(
    not(doctest),
    doc = " - A disabled extension can be `enable`d at any time giving the permissions"
)]
#[cfg_attr(not(doctest), doc = " back to the extension.")]
#[cfg_attr(
    not(doctest),
    doc = " - An extension permissions follow the all-or-nothing policy. Either all of"
)]
#[cfg_attr(
    not(doctest),
    doc = " the requested permissions are granted or none of them (can't install)."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ### Examples:")]
#[cfg_attr(
    not(doctest),
    doc = " - An Auction extension can utilize the storage to store Auction-related data"
)]
#[cfg_attr(
    not(doctest),
    doc = " while utilizing the same `Kiosk` object that the items are stored in."
)]
#[cfg_attr(
    not(doctest),
    doc = " - A Marketplace extension that implements custom events and fees for the"
)]
#[cfg_attr(not(doctest), doc = " default trading functionality.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ### Notes:")]
#[cfg_attr(
    not(doctest),
    doc = " - Trading functionality can utilize the `PurchaseCap` to build a custom"
)]
#[cfg_attr(
    not(doctest),
    doc = " logic around the purchase flow. However, it should be carefully managed to"
)]
#[cfg_attr(not(doctest), doc = " prevent asset locking.")]
#[cfg_attr(
    not(doctest),
    doc = " - `kiosk_extension` is a friend module to `kiosk` and has access to its"
)]
#[cfg_attr(
    not(doctest),
    doc = " internal functions (such as `place_internal` and `lock_internal` to"
)]
#[cfg_attr(
    not(doctest),
    doc = " implement custom authorization scheme for `place` and `lock` respectively)."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod kiosk_extension {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " The Extension struct contains the data used by the extension and the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " configuration for this extension. Stored under the `ExtensionKey`"
    )]
    #[cfg_attr(not(doctest), doc = " dynamic field.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk_extension)]
    #[allow(non_snake_case)]
    pub struct Extension {
        /// Storage for the extension, an isolated Bag. By putting the extension
        /// into a single dynamic field, we reduce the amount of fields on the
        /// top level (eg items / listings) while giving extension developers
        /// the ability to store any data they want.
        pub storage: super::bag::Bag,
        /// Bitmap of permissions that the extension has (can be revoked any
        /// moment). It's all or nothing policy - either the extension has the
        /// required permissions or no permissions at all.
        ///
        /// 1st bit - `place` - allows to place items for sale
        /// 2nd bit - `lock` and `place` - allows to lock items (and place)
        ///
        /// For example:
        /// - `10` - allows to place items and lock them.
        /// - `11` - allows to place items and lock them (`lock` includes `place`).
        /// - `01` - allows to place items, but not lock them.
        /// - `00` - no permissions.
        pub permissions: u128,
        /// Whether the extension can call protected actions. By default, all
        /// extensions are enabled (on `add` call), however the Kiosk
        /// owner can disable them at any time.
        ///
        /// Disabling the extension does not limit its access to the storage.
        pub is_enabled: bool,
    }
    impl Extension {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            storage: super::bag::Bag,
            permissions: u128,
            is_enabled: bool,
        ) -> Self {
            Self {
                storage,
                permissions,
                is_enabled,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The `ExtensionKey` is a typed dynamic field key used to store the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " extension configuration and data. `Ext` is a phantom type that is used"
    )]
    #[cfg_attr(not(doctest), doc = " to identify the extension witness.")]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = kiosk_extension)]
    #[allow(non_snake_case)]
    pub struct ExtensionKey<Ext> {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
        #[serde(skip)]
        _Ext: ::std::marker::PhantomData<Ext>,
    }
    impl<Ext> ExtensionKey<Ext> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self {
                dummy_field: false,
                _Ext: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines the `TransferPolicy` type and the logic to approve `TransferRequest`s."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - TransferPolicy - is a highly customizable primitive, which provides an"
)]
#[cfg_attr(
    not(doctest),
    doc = " interface for the type owner to set custom transfer rules for every"
)]
#[cfg_attr(
    not(doctest),
    doc = " deal performed in the `Kiosk` or a similar system that integrates with TP."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - Once a `TransferPolicy<T>` is created for and shared (or frozen), the"
)]
#[cfg_attr(
    not(doctest),
    doc = " type `T` becomes tradable in `Kiosk`s. On every purchase operation, a"
)]
#[cfg_attr(
    not(doctest),
    doc = " `TransferRequest` is created and needs to be confirmed by the `TransferPolicy`"
)]
#[cfg_attr(not(doctest), doc = " hot potato or transaction will fail.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - Type owner (creator) can set any Rules as long as the ecosystem supports"
)]
#[cfg_attr(
    not(doctest),
    doc = " them. All of the Rules need to be resolved within a single transaction (eg"
)]
#[cfg_attr(
    not(doctest),
    doc = " pay royalty and pay fixed commission). Once required actions are performed,"
)]
#[cfg_attr(
    not(doctest),
    doc = " the `TransferRequest` can be \"confirmed\" via `confirm_request` call."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " - `TransferPolicy` aims to be the main interface for creators to control trades"
)]
#[cfg_attr(
    not(doctest),
    doc = " of their types and collect profits if a fee is required on sales. Custom"
)]
#[cfg_attr(
    not(doctest),
    doc = " policies can be removed at any moment, and the change will affect all instances"
)]
#[cfg_attr(not(doctest), doc = " of the type at once.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod transfer_policy {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A \"Hot Potato\" forcing the buyer to get a transfer permission"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " from the item type (`T`) owner on purchase attempt."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer_policy)]
    #[allow(non_snake_case)]
    pub struct TransferRequest<T> {
        /// The ID of the transferred item. Although the `T` has no
        /// constraints, the main use case for this module is to work
        /// with Objects.
        pub item: super::object::ID,
        /// Amount of SUI paid for the item. Can be used to
        /// calculate the fee / transfer policy enforcement.
        pub paid: u64,
        /// The ID of the Kiosk / Safe the object is being sold from.
        /// Can be used by the TransferPolicy implementors.
        pub from: super::object::ID,
        /// Collected Receipts. Used to verify that all of the rules
        /// were followed and `TransferRequest` can be confirmed.
        pub receipts: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TransferRequest<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            item: super::object::ID,
            paid: u64,
            from: super::object::ID,
            receipts: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        ) -> Self {
            Self {
                item,
                paid,
                from,
                receipts,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A unique capability that allows the owner of the `T` to authorize"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " transfers. Can only be created with the `Publisher` object. Although"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " there's no limitation to how many policies can be created, for most"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " of the cases there's no need to create more than one since any of the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " policies can be used to confirm the `TransferRequest`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer_policy)]
    #[allow(non_snake_case)]
    pub struct TransferPolicy<T> {
        pub id: super::object::UID,
        /// The Balance of the `TransferPolicy` which collects `SUI`.
        /// By default, transfer policy does not collect anything , and it's
        /// a matter of an implementation of a specific rule - whether to add
        /// to balance and how much.
        pub balance: super::balance::Balance<super::sui::SUI>,
        /// Set of types of attached rules - used to verify `receipts` when
        /// a `TransferRequest` is received in `confirm_request` function.
        ///
        /// Additionally provides a way to look up currently attached Rules.
        pub rules: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TransferPolicy<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            balance: super::balance::Balance<super::sui::SUI>,
            rules: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        ) -> Self {
            Self {
                id,
                balance,
                rules,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for TransferPolicy<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A Capability granting the owner permission to add/remove rules as well"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " as to `withdraw` and `destroy_and_withdraw` the `TransferPolicy`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer_policy)]
    #[allow(non_snake_case)]
    pub struct TransferPolicyCap<T> {
        pub id: super::object::UID,
        pub policy_id: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TransferPolicyCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, policy_id: super::object::ID) -> Self {
            Self {
                id,
                policy_id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for TransferPolicyCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Event that is emitted when a publisher creates a new `TransferPolicyCap`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " making the discoverability and tracking the supported types easier."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer_policy)]
    #[allow(non_snake_case)]
    pub struct TransferPolicyCreated<T> {
        pub id: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TransferPolicyCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Event that is emitted when a publisher destroys a `TransferPolicyCap`."
    )]
    #[cfg_attr(not(doctest), doc = " Allows for tracking supported policies.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer_policy)]
    #[allow(non_snake_case)]
    pub struct TransferPolicyDestroyed<T> {
        pub id: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TransferPolicyDestroyed<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Key to store \"Rule\" configuration for a specific `TransferPolicy`."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer_policy)]
    #[allow(non_snake_case)]
    pub struct RuleKey<T> {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> RuleKey<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self {
                dummy_field: false,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::table` but the values are linked together, allowing for ordered insertion and"
)]
#[cfg_attr(not(doctest), doc = " removal")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod linked_table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = linked_table)]
    #[allow(non_snake_case)]
    pub struct LinkedTable<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        /// the front of the table, i.e. the key of the first entry
        pub head: Option<K>,
        /// the back of the table, i.e. the key of the last entry
        pub tail: Option<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> LinkedTable<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            size: u64,
            head: Option<K>,
            tail: Option<K>,
        ) -> Self {
            Self {
                id,
                size,
                head,
                tail,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<K, V> ::moverox::traits::HasKey for LinkedTable<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = linked_table)]
    #[allow(non_snake_case)]
    pub struct Node<K, V> {
        /// the previous key
        pub prev: Option<K>,
        /// the next key
        pub next: Option<K>,
        /// the value being stored
        pub value: V,
    }
    impl<K, V> Node<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(prev: Option<K>, next: Option<K>, value: V) -> Self {
            Self { prev, next, value }
        }
    }
}
#[cfg_attr(not(doctest), doc = " Sui object identifiers")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod object {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " An object ID. This is used to reference Sui Objects."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This is *not* guaranteed to be globally unique--anyone can create an `ID` from a `UID` or"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " from an object, and ID's can be freely copied and dropped."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Here, the values are not globally unique because there can be multiple values of type `ID`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " with the same underlying bytes. For example, `object::id(&obj)` can be called as many times"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " as you want for a given `obj`, and each `ID` value will be identical."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object)]
    #[allow(non_snake_case)]
    pub struct ID {
        pub bytes: address,
    }
    impl ID {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: address) -> Self {
            Self { bytes }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Globally unique IDs that define an object's ID in storage. Any Sui Object, that is a struct"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " with the `key` ability, must have `id: UID` as its first field."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " These are globally unique in the sense that no two values of type `UID` are ever equal, in"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " other words for any two values `id1: UID` and `id2: UID`, `id1` != `id2`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This is a privileged type that can only be derived from a `TxContext`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `UID` doesn't have the `drop` ability, so deleting a `UID` requires a call to `delete`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object)]
    #[allow(non_snake_case)]
    pub struct UID {
        pub id: super::object::ID,
    }
    impl UID {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self { id }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::bag`, an `ObjectBag` is a heterogeneous map-like collection. But unlike"
)]
#[cfg_attr(
    not(doctest),
    doc = " `sui::bag`, the values bound to these dynamic fields _must_ be objects themselves. This allows"
)]
#[cfg_attr(
    not(doctest),
    doc = " for the objects to still exist in storage, which may be important for external tools."
)]
#[cfg_attr(
    not(doctest),
    doc = " The difference is otherwise not observable from within Move."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod object_bag {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object_bag)]
    #[allow(non_snake_case)]
    pub struct ObjectBag {
        /// the ID of this bag
        pub id: super::object::UID,
        /// the number of key-value pairs in the bag
        pub size: u64,
    }
    impl ObjectBag {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self { id, size }
        }
    }
    impl ::moverox::traits::HasKey for ObjectBag {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::table`, an `ObjectTable<K, V>` is a map-like collection. But unlike"
)]
#[cfg_attr(
    not(doctest),
    doc = " `sui::table`, the values bound to these dynamic fields _must_ be objects themselves. This allows"
)]
#[cfg_attr(
    not(doctest),
    doc = " for the objects to still exist within in storage, which may be important for external tools."
)]
#[cfg_attr(
    not(doctest),
    doc = " The difference is otherwise not observable from within Move."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod object_table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object_table)]
    #[allow(non_snake_case)]
    pub struct ObjectTable<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        #[serde(skip)]
        _K: ::std::marker::PhantomData<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> ObjectTable<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self {
                id,
                size,
                _K: ::std::marker::PhantomData,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<K, V> ::moverox::traits::HasKey for ObjectTable<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Functions for operating on Move packages from within Move:"
)]
#[cfg_attr(
    not(doctest),
    doc = " - Creating proof-of-publish objects from one-time witnesses"
)]
#[cfg_attr(
    not(doctest),
    doc = " - Administering package upgrades through upgrade policies."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod package {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " This type can only be created in the transaction that"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " generates a module, by consuming its one-time witness, so it"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " can be used to identify the address that published the package"
    )]
    #[cfg_attr(not(doctest), doc = " a type originated from.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct Publisher {
        pub id: super::object::UID,
        pub package: ::moverox_sui::std::ascii::String,
        pub module_name: ::moverox_sui::std::ascii::String,
    }
    impl Publisher {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            package: ::moverox_sui::std::ascii::String,
            module_name: ::moverox_sui::std::ascii::String,
        ) -> Self {
            Self { id, package, module_name }
        }
    }
    impl ::moverox::traits::HasKey for Publisher {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Capability controlling the ability to upgrade a package."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeCap {
        pub id: super::object::UID,
        /// (Mutable) ID of the package that can be upgraded.
        pub package: super::object::ID,
        /// (Mutable) The number of upgrades that have been applied
        /// successively to the original package.  Initially 0.
        pub version: u64,
        /// What kind of upgrades are allowed.
        pub policy: u8,
    }
    impl UpgradeCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            package: super::object::ID,
            version: u64,
            policy: u8,
        ) -> Self {
            Self {
                id,
                package,
                version,
                policy,
            }
        }
    }
    impl ::moverox::traits::HasKey for UpgradeCap {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Permission to perform a particular upgrade (for a fixed version of"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the package, bytecode to upgrade with and transitive dependencies to"
    )]
    #[cfg_attr(not(doctest), doc = " depend against).")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " An `UpgradeCap` can only issue one ticket at a time, to prevent races"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " between concurrent updates or a change in its upgrade policy after"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " issuing a ticket, so the ticket is a \"Hot Potato\" to preserve forward"
    )]
    #[cfg_attr(not(doctest), doc = " progress.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeTicket {
        /// (Immutable) ID of the `UpgradeCap` this originated from.
        pub cap: super::object::ID,
        /// (Immutable) ID of the package that can be upgraded.
        pub package: super::object::ID,
        /// (Immutable) The policy regarding what kind of upgrade this ticket
        /// permits.
        pub policy: u8,
        /// (Immutable) SHA256 digest of the bytecode and transitive
        /// dependencies that will be used in the upgrade.
        pub digest: vector<u8>,
    }
    impl UpgradeTicket {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            cap: super::object::ID,
            package: super::object::ID,
            policy: u8,
            digest: vector<u8>,
        ) -> Self {
            Self {
                cap,
                package,
                policy,
                digest,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Issued as a result of a successful upgrade, containing the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " information to be used to update the `UpgradeCap`.  This is a \"Hot"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Potato\" to ensure that it is used to update its `UpgradeCap` before"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the end of the transaction that performed the upgrade."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeReceipt {
        /// (Immutable) ID of the `UpgradeCap` this originated from.
        pub cap: super::object::ID,
        /// (Immutable) ID of the package after it was upgraded.
        pub package: super::object::ID,
    }
    impl UpgradeReceipt {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(cap: super::object::ID, package: super::object::ID) -> Self {
            Self { cap, package }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod party {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " The permissions that apply to a party object. If the transaction sender has an entry in"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the `members` map, the permissions in that entry apply. Otherwise, the `default` permissions"
    )]
    #[cfg_attr(not(doctest), doc = " are used.")]
    #[cfg_attr(
        not(doctest),
        doc = " If the party has the `READ` permission, the object can be taken as an immutable input."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " If the party has the `WRITE`, `DELETE`, or `TRANSFER` permissions, the object can be taken as"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " a mutable input. Additional restrictions pertaining to each permission are checked at the end"
    )]
    #[cfg_attr(not(doctest), doc = " of transaction execution.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = party)]
    #[allow(non_snake_case)]
    pub struct Party {
        /// The permissions that apply if no specific permissions are set in the `members` map.
        pub default: Permissions,
        /// The permissions per transaction sender.
        pub members: super::vec_map::VecMap<address, Permissions>,
    }
    impl Party {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            default: Permissions,
            members: super::vec_map::VecMap<address, Permissions>,
        ) -> Self {
            Self { default, members }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The permissions that a party has. The permissions are a bitset of the `READ`, `WRITE`,"
    )]
    #[cfg_attr(not(doctest), doc = " `DELETE`, and `TRANSFER` constants.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = party)]
    #[allow(non_snake_case)]
    pub struct Permissions(pub u64);
    impl Permissions {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: u64) -> Self {
            Self(_0)
        }
    }
}
#[cfg_attr(not(doctest), doc = " Priority queue implemented using a max heap.")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod priority_queue {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Struct representing a priority queue. The `entries` vector represents a max"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " heap structure, where entries[0] is the root, entries[1] and entries[2] are the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " left child and right child of the root, etc. More generally, the children of"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " entries[i] are at i * 2 + 1 and i * 2 + 2. The max heap should have the invariant"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " that the parent node's priority is always higher than its child nodes' priorities."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = priority_queue)]
    #[allow(non_snake_case)]
    pub struct PriorityQueue<T> {
        pub entries: vector<Entry<T>>,
    }
    impl<T> PriorityQueue<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(entries: vector<Entry<T>>) -> Self {
            Self { entries }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = priority_queue)]
    #[allow(non_snake_case)]
    pub struct Entry<T> {
        pub priority: u64,
        pub value: T,
    }
    impl<T> Entry<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(priority: u64, value: T) -> Self {
            Self { priority, value }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " This module provides functionality for generating secure randomness."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod random {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Singleton shared object which stores the global randomness state."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The actual state is stored in a versioned inner field."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct Random {
        pub id: super::object::UID,
        pub inner: super::versioned::Versioned,
    }
    impl Random {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            inner: super::versioned::Versioned,
        ) -> Self {
            Self { id, inner }
        }
    }
    impl ::moverox::traits::HasKey for Random {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct RandomInner {
        pub version: u64,
        pub epoch: u64,
        pub randomness_round: u64,
        pub random_bytes: vector<u8>,
    }
    impl RandomInner {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            version: u64,
            epoch: u64,
            randomness_round: u64,
            random_bytes: vector<u8>,
        ) -> Self {
            Self {
                version,
                epoch,
                randomness_round,
                random_bytes,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Unique randomness generator, derived from the global randomness."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct RandomGenerator {
        pub seed: vector<u8>,
        pub counter: u16,
        pub buffer: vector<u8>,
    }
    impl RandomGenerator {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(seed: vector<u8>, counter: u16, buffer: vector<u8>) -> Self {
            Self { seed, counter, buffer }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines the system object for managing coin data in a central"
)]
#[cfg_attr(
    not(doctest),
    doc = " registry. This module provides a centralized way to store and manage"
)]
#[cfg_attr(
    not(doctest),
    doc = " metadata for all currencies in the Sui ecosystem, including their"
)]
#[cfg_attr(
    not(doctest),
    doc = " supply information, regulatory status, and metadata capabilities."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod coin_registry {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " System object found at address `0xc` that stores coin data for all"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " registered coin types. This is a shared object that acts as a central"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " registry for coin metadata, supply information, and regulatory status."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct CoinRegistry {
        pub id: super::object::UID,
    }
    impl CoinRegistry {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self { id }
        }
    }
    impl ::moverox::traits::HasKey for CoinRegistry {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Store only object that enables more flexible coin data"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " registration, allowing for additional fields to be added"
    )]
    #[cfg_attr(not(doctest), doc = " without changing the `Currency` structure.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct ExtraField(pub ::moverox_sui::std::type_name::TypeName, pub vector<u8>);
    impl ExtraField {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            _0: ::moverox_sui::std::type_name::TypeName,
            _1: vector<u8>,
        ) -> Self {
            Self(_0, _1)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Key used to derive addresses when creating `Currency<T>` objects."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct CurrencyKey<T>(bool, #[serde(skip)] ::std::marker::PhantomData<T>);
    impl<T> CurrencyKey<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false, ::std::marker::PhantomData)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Key used to store the legacy `CoinMetadata` for a `Currency`."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct LegacyMetadataKey(bool);
    impl LegacyMetadataKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Capability object that gates metadata (name, description, icon_url, symbol)"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " changes in the `Currency`. It can only be created (or claimed) once, and can"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " be deleted to prevent changes to the `Currency` metadata."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct MetadataCap<T> {
        pub id: super::object::UID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> MetadataCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for MetadataCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Potato callback for the legacy `CoinMetadata` borrowing."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct Borrow<T> {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Borrow<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self {
                dummy_field: false,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Currency stores metadata such as name, symbol, decimals, icon_url and description,"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " as well as supply states (optional) and regulatory status."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct Currency<T> {
        pub id: super::object::UID,
        /// Number of decimal places the coin uses for display purposes.
        pub decimals: u8,
        /// Human-readable name for the coin.
        pub name: ::moverox_sui::std::string::String,
        /// Short symbol/ticker for the coin.
        pub symbol: ::moverox_sui::std::string::String,
        /// Detailed description of the coin.
        pub description: ::moverox_sui::std::string::String,
        /// URL for the coin's icon/logo.
        pub icon_url: ::moverox_sui::std::string::String,
        /// Current supply state of the coin (fixed supply or unknown)
        /// Note: We're using `Option` because `SupplyState` does not have drop,
        /// meaning we cannot swap out its value at a later state.
        pub supply: Option<SupplyState<T>>,
        /// Regulatory status of the coin (regulated with deny cap or unknown)
        pub regulated: RegulatedState,
        /// ID of the treasury cap for this coin type, if registered.
        pub treasury_cap_id: Option<super::object::ID>,
        /// ID of the metadata capability for this coin type, if claimed.
        pub metadata_cap_id: MetadataCapState,
        /// Additional fields for extensibility.
        pub extra_fields: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            ExtraField,
        >,
    }
    impl<T> Currency<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            decimals: u8,
            name: ::moverox_sui::std::string::String,
            symbol: ::moverox_sui::std::string::String,
            description: ::moverox_sui::std::string::String,
            icon_url: ::moverox_sui::std::string::String,
            supply: Option<SupplyState<T>>,
            regulated: RegulatedState,
            treasury_cap_id: Option<super::object::ID>,
            metadata_cap_id: MetadataCapState,
            extra_fields: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                ExtraField,
            >,
        ) -> Self {
            Self {
                id,
                decimals,
                name,
                symbol,
                description,
                icon_url,
                supply,
                regulated,
                treasury_cap_id,
                metadata_cap_id,
                extra_fields,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for Currency<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Supply state marks the type of Currency Supply, which can be"
    )]
    #[cfg_attr(not(doctest), doc = " - Fixed: no minting or burning;")]
    #[cfg_attr(not(doctest), doc = " - BurnOnly: no minting, burning is allowed;")]
    #[cfg_attr(
        not(doctest),
        doc = " - Unknown: flexible (supply is controlled by its `TreasuryCap`);"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub enum SupplyState<T> {
        /// Coin has a fixed supply with the given Supply object.
        Fixed(super::balance::Supply<T>),
        /// Coin has a supply that can ONLY decrease.
        BurnOnly(super::balance::Supply<T>),
        /// Supply information is not yet known or registered.
        Unknown,
    }
    #[cfg_attr(not(doctest), doc = " Regulated state of a coin type.")]
    #[cfg_attr(
        not(doctest),
        doc = " - Regulated: `DenyCap` exists or a `RegulatedCoinMetadata` used to mark currency as regulated;"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " - Unregulated: the currency was created without deny list;"
    )]
    #[cfg_attr(not(doctest), doc = " - Unknown: the regulatory status is unknown.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub enum RegulatedState {
        /// Coin is regulated with a deny cap for address restrictions.
        /// `allow_global_pause` is `None` if the information is unknown (has not been migrated from `DenyCapV2`).
        Regulated {
            cap: super::object::ID,
            allow_global_pause: Option<bool>,
            variant: u8,
        },
        /// The coin has been created without deny list.
        Unregulated,
        /// Regulatory status is unknown.
        /// Result of a legacy migration for that coin (from `coin.move` constructors)
        Unknown,
    }
    #[cfg_attr(
        not(doctest),
        doc = " State of the `MetadataCap` for a single `Currency`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub enum MetadataCapState {
        /// The metadata cap has been claimed.
        Claimed(super::object::ID),
        /// The metadata cap has not been claimed.
        Unclaimed,
        /// The metadata cap has been claimed and then deleted.
        Deleted,
    }
    #[cfg_attr(
        not(doctest),
        doc = " Hot potato wrapper to enforce registration after \"new_currency\" data creation."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Destroyed in the `finalize` call and either transferred to the `CoinRegistry`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " (in case of an OTW registration) or shared directly (for dynamically created"
    )]
    #[cfg_attr(not(doctest), doc = " currencies).")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin_registry)]
    #[allow(non_snake_case)]
    pub struct CurrencyInitializer<T> {
        pub currency: Currency<T>,
        pub extra_fields: super::bag::Bag,
        pub is_otw: bool,
    }
    impl<T> CurrencyInitializer<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            currency: Currency<T>,
            extra_fields: super::bag::Bag,
            is_otw: bool,
        ) -> Self {
            Self {
                currency,
                extra_fields,
                is_otw,
            }
        }
    }
}
#[cfg_attr(not(doctest), doc = " Coin<SUI> is the token used to pay for gas in Sui.")]
#[cfg_attr(
    not(doctest),
    doc = " It has 9 decimals, and the smallest unit (10^-9) is called \"mist\"."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod sui {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " Name of the coin")]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = sui)]
    #[allow(non_snake_case)]
    pub struct SUI {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl SUI {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A table is a map-like collection. But unlike a traditional collection, it's keys and values are"
)]
#[cfg_attr(
    not(doctest),
    doc = " not stored within the `Table` value, but instead are stored using Sui's object system. The"
)]
#[cfg_attr(
    not(doctest),
    doc = " `Table` struct acts only as a handle into the object system to retrieve those keys and values."
)]
#[cfg_attr(
    not(doctest),
    doc = " Note that this means that `Table` values with exactly the same key-value mapping will not be"
)]
#[cfg_attr(not(doctest), doc = " equal, with `==`, at runtime. For example")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = " let table1 = table::new<u64, bool>();")]
#[cfg_attr(not(doctest), doc = " let table2 = table::new<u64, bool>();")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table1, 0, false);")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table1, 1, true);")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table2, 0, false);")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table2, 1, true);")]
#[cfg_attr(
    not(doctest),
    doc = " // table1 does not equal table2, despite having the same entries"
)]
#[cfg_attr(not(doctest), doc = " assert!(&table1 != &table2);")]
#[cfg_attr(not(doctest), doc = " ```")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = table)]
    #[allow(non_snake_case)]
    pub struct Table<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        #[serde(skip)]
        _K: ::std::marker::PhantomData<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> Table<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self {
                id,
                size,
                _K: ::std::marker::PhantomData,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<K, V> ::moverox::traits::HasKey for Table<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A basic scalable vector library implemented using `Table`."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod table_vec {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = table_vec)]
    #[allow(non_snake_case)]
    pub struct TableVec<Element> {
        /// The contents of the table vector.
        pub contents: super::table::Table<u64, Element>,
    }
    impl<Element> TableVec<Element> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: super::table::Table<u64, Element>) -> Self {
            Self { contents }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod test_scenario {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Utility for mocking a multi-transaction Sui execution in a single Move procedure."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " A `Scenario` maintains a view of the global object pool built up by the execution."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " These objects can be accessed via functions like `take_from_sender`, which gives the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " transaction sender access to objects in (only) their inventory."
    )]
    #[cfg_attr(not(doctest), doc = " Example usage:")]
    #[cfg_attr(not(doctest), doc = " ```")]
    #[cfg_attr(not(doctest), doc = " let addr1: address = 0;")]
    #[cfg_attr(not(doctest), doc = " let addr2: address = 1;")]
    #[cfg_attr(
        not(doctest),
        doc = " // begin a test scenario in a context where addr1 is the sender"
    )]
    #[cfg_attr(not(doctest), doc = " let scenario = &mut test_scenario::begin(addr1);")]
    #[cfg_attr(not(doctest), doc = " // addr1 sends an object to addr2")]
    #[cfg_attr(not(doctest), doc = " {")]
    #[cfg_attr(
        not(doctest),
        doc = "     let some_object: SomeObject = ... // construct an object"
    )]
    #[cfg_attr(
        not(doctest),
        doc = "     transfer::public_transfer(some_object, copy addr2)"
    )]
    #[cfg_attr(not(doctest), doc = " };")]
    #[cfg_attr(
        not(doctest),
        doc = " // end the first transaction and begin a new one where addr2 is the sender"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " // Starting a new transaction moves any objects transferred into their respective"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " // inventories. In other words, if you call `take_from_sender` before `next_tx`, `addr2`"
    )]
    #[cfg_attr(not(doctest), doc = " // will not yet have `some_object`")]
    #[cfg_attr(not(doctest), doc = " test_scenario::next_tx(scenario, addr2);")]
    #[cfg_attr(not(doctest), doc = " {")]
    #[cfg_attr(
        not(doctest),
        doc = "     // remove the SomeObject value from addr2's inventory"
    )]
    #[cfg_attr(
        not(doctest),
        doc = "     let obj = test_scenario::take_from_sender<SomeObject>(scenario);"
    )]
    #[cfg_attr(
        not(doctest),
        doc = "     // use it to test some function that needs this value"
    )]
    #[cfg_attr(not(doctest), doc = "     SomeObject::some_function(obj)")]
    #[cfg_attr(not(doctest), doc = " };")]
    #[cfg_attr(not(doctest), doc = " ... // more txes")]
    #[cfg_attr(not(doctest), doc = " test_scenario::end(scenario);")]
    #[cfg_attr(not(doctest), doc = " ```")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = test_scenario)]
    #[allow(non_snake_case)]
    pub struct Scenario {
        pub txn_number: u64,
        pub ctx: super::tx_context::TxContext,
    }
    impl Scenario {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(txn_number: u64, ctx: super::tx_context::TxContext) -> Self {
            Self { txn_number, ctx }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Builder for a `TxContext` to use in a test scenario."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = test_scenario)]
    #[allow(non_snake_case)]
    pub struct TxContextBuilder {
        pub sender: address,
        pub epoch: u64,
        pub epoch_timestamp_ms: u64,
        pub ids_created: u64,
        pub rgp: Option<u64>,
        pub gas_price: u64,
        pub gas_budget: u64,
        pub sponsor: Option<address>,
    }
    impl TxContextBuilder {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            sender: address,
            epoch: u64,
            epoch_timestamp_ms: u64,
            ids_created: u64,
            rgp: Option<u64>,
            gas_price: u64,
            gas_budget: u64,
            sponsor: Option<address>,
        ) -> Self {
            Self {
                sender,
                epoch,
                epoch_timestamp_ms,
                ids_created,
                rgp,
                gas_price,
                gas_budget,
                sponsor,
            }
        }
    }
    #[cfg_attr(not(doctest), doc = " The effects of a transaction")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = test_scenario)]
    #[allow(non_snake_case)]
    pub struct TransactionEffects {
        /// The objects created this transaction
        pub created: vector<super::object::ID>,
        /// The objects written/modified this transaction
        pub written: vector<super::object::ID>,
        /// The objects deleted this transaction
        pub deleted: vector<super::object::ID>,
        /// The objects transferred to an account this transaction
        pub transferred_to_account: super::vec_map::VecMap<super::object::ID, address>,
        /// The objects transferred to an object this transaction
        pub transferred_to_object: super::vec_map::VecMap<
            super::object::ID,
            super::object::ID,
        >,
        /// The objects shared this transaction
        pub shared: vector<super::object::ID>,
        /// The objects frozen this transaction
        pub frozen: vector<super::object::ID>,
        /// The number of user events emitted this transaction
        pub num_user_events: u64,
    }
    impl TransactionEffects {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            created: vector<super::object::ID>,
            written: vector<super::object::ID>,
            deleted: vector<super::object::ID>,
            transferred_to_account: super::vec_map::VecMap<super::object::ID, address>,
            transferred_to_object: super::vec_map::VecMap<
                super::object::ID,
                super::object::ID,
            >,
            shared: vector<super::object::ID>,
            frozen: vector<super::object::ID>,
            num_user_events: u64,
        ) -> Self {
            Self {
                created,
                written,
                deleted,
                transferred_to_account,
                transferred_to_object,
                shared,
                frozen,
                num_user_events,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " The Token module which implements a Closed Loop Token with a configurable"
)]
#[cfg_attr(
    not(doctest),
    doc = " policy. The policy is defined by a set of rules that must be satisfied for"
)]
#[cfg_attr(not(doctest), doc = " an action to be performed on the token.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " The module is designed to be used with a `TreasuryCap` to allow for minting"
)]
#[cfg_attr(
    not(doctest),
    doc = " and burning of the `Token`s. And can act as a replacement / extension or a"
)]
#[cfg_attr(not(doctest), doc = " companion to existing open-loop (`Coin`) systems.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(
    not(doctest),
    doc = " Module:      sui::balance       sui::coin             sui::token"
)]
#[cfg_attr(
    not(doctest),
    doc = " Main type:   Balance<T>         Coin<T>               Token<T>"
)]
#[cfg_attr(
    not(doctest),
    doc = " Capability:  Supply<T>  <---->  TreasuryCap<T> <----> TreasuryCap<T>"
)]
#[cfg_attr(
    not(doctest),
    doc = " Abilities:   store              key + store           key"
)]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " The Token system allows for fine-grained control over the actions performed"
)]
#[cfg_attr(
    not(doctest),
    doc = " on the token. And hence it is highly suitable for applications that require"
)]
#[cfg_attr(
    not(doctest),
    doc = " control over the currency which a simple open-loop system can't provide."
)]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod token {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A single `Token` with `Balance` inside. Can only be owned by an address,"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " and actions performed on it must be confirmed in a matching `TokenPolicy`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct Token<T> {
        pub id: super::object::UID,
        /// The Balance of the `Token`.
        pub balance: super::balance::Balance<T>,
    }
    impl<T> Token<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            balance: super::balance::Balance<T>,
        ) -> Self {
            Self { id, balance }
        }
    }
    impl<T> ::moverox::traits::HasKey for Token<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A Capability that manages a single `TokenPolicy` specified in the `for`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " field. Created together with `TokenPolicy` in the `new` function."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicyCap<T> {
        pub id: super::object::UID,
        pub r#for: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicyCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, r#for: super::object::ID) -> Self {
            Self {
                id,
                r#for,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for TokenPolicyCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " `TokenPolicy` represents a set of rules that define what actions can be"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " performed on a `Token` and which `Rules` must be satisfied for the"
    )]
    #[cfg_attr(not(doctest), doc = " action to succeed.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " - For the sake of availability, `TokenPolicy` is a `key`-only object."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " - Each `TokenPolicy` is managed by a matching `TokenPolicyCap`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " - For an action to become available, there needs to be a record in the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `rules` VecMap. To allow an action to be performed freely, there's an"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `allow` function that can be called by the `TokenPolicyCap` owner."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicy<T> {
        pub id: super::object::UID,
        /// The balance that is effectively spent by the user on the "spend"
        /// action. However, actual decrease of the supply can only be done by
        /// the `TreasuryCap` owner when `flush` is called.
        ///
        /// This balance is effectively spent and cannot be accessed by anyone
        /// but the `TreasuryCap` owner.
        pub spent_balance: super::balance::Balance<T>,
        /// The set of rules that define what actions can be performed on the
        /// token. For each "action" there's a set of Rules that must be
        /// satisfied for the `ActionRequest` to be confirmed.
        pub rules: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        >,
    }
    impl<T> TokenPolicy<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            spent_balance: super::balance::Balance<T>,
            rules: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
            >,
        ) -> Self {
            Self { id, spent_balance, rules }
        }
    }
    impl<T> ::moverox::traits::HasKey for TokenPolicy<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A request to perform an \"Action\" on a token. Stores the information"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " about the action to be performed and must be consumed by the `confirm_request`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " or `confirm_request_mut` functions when the Rules are satisfied."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct ActionRequest<T> {
        /// Name of the Action to look up in the Policy. Name can be one of the
        /// default actions: `transfer`, `spend`, `to_coin`, `from_coin` or a
        /// custom action.
        pub name: ::moverox_sui::std::string::String,
        /// Amount is present in all of the txs
        pub amount: u64,
        /// Sender is a permanent field always
        pub sender: address,
        /// Recipient is only available in `transfer` action.
        pub recipient: Option<address>,
        /// The balance to be "spent" in the `TokenPolicy`, only available
        /// in the `spend` action.
        pub spent_balance: Option<super::balance::Balance<T>>,
        /// Collected approvals (stamps) from completed `Rules`. They're matched
        /// against `TokenPolicy.rules` to determine if the request can be
        /// confirmed.
        pub approvals: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
    }
    impl<T> ActionRequest<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            name: ::moverox_sui::std::string::String,
            amount: u64,
            sender: address,
            recipient: Option<address>,
            spent_balance: Option<super::balance::Balance<T>>,
            approvals: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        ) -> Self {
            Self {
                name,
                amount,
                sender,
                recipient,
                spent_balance,
                approvals,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Dynamic field key for the `TokenPolicy` to store the `Config` for a"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " specific action `Rule`. There can be only one configuration per"
    )]
    #[cfg_attr(not(doctest), doc = " `Rule` per `TokenPolicy`.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct RuleKey<T> {
        pub is_protected: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> RuleKey<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(is_protected: bool) -> Self {
            Self {
                is_protected,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " An event emitted when a `TokenPolicy` is created and shared. Because"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `TokenPolicy` can only be shared (and potentially frozen in the future),"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " we emit this event in the `share_policy` function and mark it as mutable."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicyCreated<T> {
        /// ID of the `TokenPolicy` that was created.
        pub id: super::object::ID,
        /// Whether the `TokenPolicy` is "shared" (mutable) or "frozen"
        /// (immutable) - TBD.
        pub is_mutable: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicyCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID, is_mutable: bool) -> Self {
            Self {
                id,
                is_mutable,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod transfer {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " This represents the ability to `receive` an object of type `T`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This type is ephemeral per-transaction and cannot be stored on-chain."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This does not represent the obligation to receive the object that it"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " references, but simply the ability to receive the object with object ID"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `id` at version `version` if you can prove mutable access to the parent"
    )]
    #[cfg_attr(not(doctest), doc = " object during the transaction.")]
    #[cfg_attr(
        not(doctest),
        doc = " Internals of this struct are opaque outside this module."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer)]
    #[allow(non_snake_case)]
    pub struct Receiving<T> {
        pub id: super::object::ID,
        pub version: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Receiving<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID, version: u64) -> Self {
            Self {
                id,
                version,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod tx_context {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Information about the transaction currently being executed."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This cannot be constructed by a transaction--it is a privileged object created by"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the VM and passed in to the entrypoint of the transaction as `&mut TxContext`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = tx_context)]
    #[allow(non_snake_case)]
    pub struct TxContext {
        /// The address of the user that signed the current transaction
        pub sender: address,
        /// Hash of the current transaction
        pub tx_hash: vector<u8>,
        /// The current epoch number
        pub epoch: u64,
        /// Timestamp that the epoch started at
        pub epoch_timestamp_ms: u64,
        /// Counter recording the number of fresh id's created while executing
        /// this transaction. Always 0 at the start of a transaction
        pub ids_created: u64,
    }
    impl TxContext {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            sender: address,
            tx_hash: vector<u8>,
            epoch: u64,
            epoch_timestamp_ms: u64,
            ids_created: u64,
        ) -> Self {
            Self {
                sender,
                tx_hash,
                epoch,
                epoch_timestamp_ms,
                ids_created,
            }
        }
    }
}
#[cfg_attr(not(doctest), doc = " URL: standard Uniform Resource Locator string")]
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod url {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " Standard Uniform Resource Locator (URL) string.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = url)]
    #[allow(non_snake_case)]
    pub struct Url {
        pub url: ::moverox_sui::std::ascii::String,
    }
    impl Url {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(url: ::moverox_sui::std::ascii::String) -> Self {
            Self { url }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod vec_map {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A map data structure backed by a vector. The map is guaranteed not to contain duplicate keys, but entries"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " are *not* sorted by key--entries are included in insertion order."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " All operations are O(N) in the size of the map--the intention of this data structure is only to provide"
    )]
    #[cfg_attr(not(doctest), doc = " the convenience of programming against a map API.")]
    #[cfg_attr(
        not(doctest),
        doc = " Large maps should use handwritten parent/child relationships instead."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Maps that need sorted iteration rather than insertion order iteration should also be handwritten."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_map)]
    #[allow(non_snake_case)]
    pub struct VecMap<K, V> {
        pub contents: vector<Entry<K, V>>,
    }
    impl<K, V> VecMap<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: vector<Entry<K, V>>) -> Self {
            Self { contents }
        }
    }
    #[cfg_attr(not(doctest), doc = " An entry in the map")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_map)]
    #[allow(non_snake_case)]
    pub struct Entry<K, V> {
        pub key: K,
        pub value: V,
    }
    impl<K, V> Entry<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(key: K, value: V) -> Self {
            Self { key, value }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod vec_set {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A set data structure backed by a vector. The set is guaranteed not to"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " contain duplicate keys. All operations are O(N) in the size of the set"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " - the intention of this data structure is only to provide the convenience"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " of programming against a set API. Sets that need sorted iteration rather"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " than insertion order iteration should be handwritten."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_set)]
    #[allow(non_snake_case)]
    pub struct VecSet<K> {
        pub contents: vector<K>,
    }
    impl<K> VecSet<K> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: vector<K>) -> Self {
            Self { contents }
        }
    }
}
#[allow(rustdoc::all, clippy::too_long_first_doc_paragraph)]
pub mod versioned {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A wrapper type that supports versioning of the inner type."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The inner type is a dynamic field of the Versioned object, and is keyed using version."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " User of this type could load the inner object using corresponding type based on the version."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " You can also upgrade the inner object to a new type version."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " If you want to support lazy upgrade of the inner type, one caveat is that all APIs would have"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " to use mutable reference even if it's a read-only API."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = versioned)]
    #[allow(non_snake_case)]
    pub struct Versioned {
        pub id: super::object::UID,
        pub version: u64,
    }
    impl Versioned {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, version: u64) -> Self {
            Self { id, version }
        }
    }
    impl ::moverox::traits::HasKey for Versioned {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Represents a hot potato object generated when we take out the dynamic field."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This is to make sure that we always put a new value back."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = versioned)]
    #[allow(non_snake_case)]
    pub struct VersionChangeCap {
        pub versioned_id: super::object::ID,
        pub old_version: u64,
    }
    impl VersionChangeCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(versioned_id: super::object::ID, old_version: u64) -> Self {
            Self { versioned_id, old_version }
        }
    }
}
