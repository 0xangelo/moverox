---
source: crates/moverox-build/src/tests.rs
expression: sui_framework
---
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod accumulator {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator)]
    #[allow(non_snake_case)]
    pub struct AccumulatorRoot {
        pub id: super::object::UID,
    }
    impl AccumulatorRoot {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self { id }
        }
    }
    impl ::moverox::traits::HasKey for AccumulatorRoot {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod authenticator_state {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Singleton shared object which stores the global authenticator state.
    /// The actual state is stored in a dynamic field of type AuthenticatorStateInner to support
    /// future versions of the authenticator state.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct AuthenticatorState {
        pub id: super::object::UID,
        pub version: u64,
    }
    impl AuthenticatorState {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, version: u64) -> Self {
            Self { id, version }
        }
    }
    impl ::moverox::traits::HasKey for AuthenticatorState {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct AuthenticatorStateInner {
        pub version: u64,
        /// List of currently active JWKs.
        pub active_jwks: vector<ActiveJwk>,
    }
    impl AuthenticatorStateInner {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(version: u64, active_jwks: vector<ActiveJwk>) -> Self {
            Self { version, active_jwks }
        }
    }
    /// Must match the JWK struct in fastcrypto-zkp
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct JWK {
        pub kty: ::moverox_sui::std::string::String,
        pub e: ::moverox_sui::std::string::String,
        pub n: ::moverox_sui::std::string::String,
        pub alg: ::moverox_sui::std::string::String,
    }
    impl JWK {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            kty: ::moverox_sui::std::string::String,
            e: ::moverox_sui::std::string::String,
            n: ::moverox_sui::std::string::String,
            alg: ::moverox_sui::std::string::String,
        ) -> Self {
            Self { kty, e, n, alg }
        }
    }
    /// Must match the JwkId struct in fastcrypto-zkp
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct JwkId {
        pub iss: ::moverox_sui::std::string::String,
        pub kid: ::moverox_sui::std::string::String,
    }
    impl JwkId {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            iss: ::moverox_sui::std::string::String,
            kid: ::moverox_sui::std::string::String,
        ) -> Self {
            Self { iss, kid }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct ActiveJwk {
        pub jwk_id: JwkId,
        pub jwk: JWK,
        pub epoch: u64,
    }
    impl ActiveJwk {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(jwk_id: JwkId, jwk: JWK, epoch: u64) -> Self {
            Self { jwk_id, jwk, epoch }
        }
    }
}
/// A bag is a heterogeneous map-like collection. The collection is similar to `sui::table` in that
/// its keys and values are not stored within the `Bag` value, but instead are stored using Sui's
/// object system. The `Bag` struct acts only as a handle into the object system to retrieve those
/// keys and values.
/// Note that this means that `Bag` values with exactly the same key-value mapping will not be
/// equal, with `==`, at runtime. For example
/// ```
/// let bag1 = bag::new();
/// let bag2 = bag::new();
/// bag::add(&mut bag1, 0, false);
/// bag::add(&mut bag1, 1, true);
/// bag::add(&mut bag2, 0, false);
/// bag::add(&mut bag2, 1, true);
/// // bag1 does not equal bag2, despite having the same entries
/// assert!(&bag1 != &bag2);
/// ```
/// At it's core, `sui::bag` is a wrapper around `UID` that allows for access to
/// `sui::dynamic_field` while preventing accidentally stranding field values. A `UID` can be
/// deleted, even if it has dynamic fields associated with it, but a bag, on the other hand, must be
/// empty to be destroyed.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod bag {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bag)]
    #[allow(non_snake_case)]
    pub struct Bag {
        /// the ID of this bag
        pub id: super::object::UID,
        /// the number of key-value pairs in the bag
        pub size: u64,
    }
    impl Bag {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self { id, size }
        }
    }
    impl ::moverox::traits::HasKey for Bag {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// A storable handler for Balances in general. Is used in the `Coin`
/// module to allow balance operations and can be used to implement
/// custom coins with `Supply` and `Balance`s.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod balance {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A Supply of T. Used for minting and burning.
    /// Wrapped into a `TreasuryCap` in the `Coin` module.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = balance)]
    #[allow(non_snake_case)]
    pub struct Supply<T> {
        pub value: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Supply<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u64) -> Self {
            Self {
                value,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    /// Storable balance - an inner struct of a Coin type.
    /// Can be used to store coins which don't need the key ability.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = balance)]
    #[allow(non_snake_case)]
    pub struct Balance<T> {
        pub value: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Balance<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u64) -> Self {
            Self {
                value,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
/// This module implements BCS (de)serialization in Move.
/// Full specification can be found here: https://github.com/diem/bcs
///
/// Short summary (for Move-supported types):
///
/// - address - sequence of X bytes
/// - bool - byte with 0 or 1
/// - u8 - a single u8 byte
/// - u16 / u32 / u64 / u128 / u256 - LE bytes
/// - vector - ULEB128 length + LEN elements
/// - option - first byte bool: None (0) or Some (1), then value
///
/// Usage example:
/// ```
/// /// This function reads u8 and u64 value from the input
/// /// and returns the rest of the bytes.
/// fun deserialize(bytes: vector<u8>): (u8, u64, vector<u8>) {
///     use sui::bcs::{Self, BCS};
///
///     let prepared: BCS = bcs::new(bytes);
///     let (u8_value, u64_value) = (
///         prepared.peel_u8(),
///         prepared.peel_u64()
///     );
///
///     // unpack bcs struct
///     let leftovers = prepared.into_remainder_bytes();
///
///     (u8_value, u64_value, leftovers)
/// }
/// ```
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod bcs {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A helper struct that saves resources on operations. For better
    /// vector performance, it stores reversed bytes of the BCS and
    /// enables use of `vector::pop_back`.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bcs)]
    #[allow(non_snake_case)]
    pub struct BCS {
        pub bytes: vector<u8>,
    }
    impl BCS {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self { bytes }
        }
    }
}
/// A simple library that enables hot-potato-locked borrow mechanics.
///
/// With Programmable transactions, it is possible to borrow a value within
/// a transaction, use it and put back in the end. Hot-potato `Borrow` makes
/// sure the object is returned and was not swapped for another one.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod borrow {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// An object wrapping a `T` and providing the borrow API.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Referent<T> {
        pub id: address,
        pub value: Option<T>,
    }
    impl<T> Referent<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: address, value: Option<T>) -> Self {
            Self { id, value }
        }
    }
    /// A hot potato making sure the object is put back once borrowed.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Borrow {
        pub r#ref: address,
        pub obj: super::object::ID,
    }
    impl Borrow {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(r#ref: address, obj: super::object::ID) -> Self {
            Self { r#ref, obj }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Test {
        pub id: super::object::UID,
    }
    impl Test {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self { id }
        }
    }
    impl ::moverox::traits::HasKey for Test {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// APIs for accessing time from move calls, via the `Clock`: a unique
/// shared object that is created at 0x6 during genesis.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod clock {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Singleton shared object that exposes time to Move calls.  This
    /// object is found at address 0x6, and can only be read (accessed
    /// via an immutable reference) by entry functions.
    ///
    /// Entry Functions that attempt to accept `Clock` by mutable
    /// reference or value will fail to verify, and honest validators
    /// will not sign or execute transactions that use `Clock` as an
    /// input parameter, unless it is passed by immutable reference.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = clock)]
    #[allow(non_snake_case)]
    pub struct Clock {
        pub id: super::object::UID,
        /// The clock's timestamp, which is set automatically by a
        /// system transaction every time consensus commits a
        /// schedule, or by `sui::clock::increment_for_testing` during
        /// testing.
        pub timestamp_ms: u64,
    }
    impl Clock {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, timestamp_ms: u64) -> Self {
            Self { id, timestamp_ms }
        }
    }
    impl ::moverox::traits::HasKey for Clock {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// Defines the `Coin` type - platform wide representation of fungible
/// tokens and coins. `Coin` can be described as a secure wrapper around
/// `Balance` type.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod coin {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A coin of type `T` worth `value`. Transferable and storable
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct Coin<T> {
        pub id: super::object::UID,
        pub balance: super::balance::Balance<T>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Coin<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            balance: super::balance::Balance<T>,
        ) -> Self {
            Self {
                id,
                balance,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for Coin<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Each Coin type T created through `create_currency` function will have a
    /// unique instance of CoinMetadata<T> that stores the metadata for this coin type.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct CoinMetadata<T> {
        pub id: super::object::UID,
        /// Number of decimal places the coin uses.
        /// A coin with `value ` N and `decimals` D should be shown as N / 10^D
        /// E.g., a coin with `value` 7002 and decimals 3 should be displayed as 7.002
        /// This is metadata for display usage only.
        pub decimals: u8,
        /// Name for the token
        pub name: ::moverox_sui::std::string::String,
        /// Symbol for the token
        pub symbol: ::moverox_sui::std::ascii::String,
        /// Description of the token
        pub description: ::moverox_sui::std::string::String,
        /// URL for the token logo
        pub icon_url: Option<super::url::Url>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> CoinMetadata<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            decimals: u8,
            name: ::moverox_sui::std::string::String,
            symbol: ::moverox_sui::std::ascii::String,
            description: ::moverox_sui::std::string::String,
            icon_url: Option<super::url::Url>,
        ) -> Self {
            Self {
                id,
                decimals,
                name,
                symbol,
                description,
                icon_url,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for CoinMetadata<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Similar to CoinMetadata, but created only for regulated coins that use the DenyList.
    /// This object is always immutable.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct RegulatedCoinMetadata<T> {
        pub id: super::object::UID,
        /// The ID of the coin's CoinMetadata object.
        pub coin_metadata_object: super::object::ID,
        /// The ID of the coin's DenyCap object.
        pub deny_cap_object: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> RegulatedCoinMetadata<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            coin_metadata_object: super::object::ID,
            deny_cap_object: super::object::ID,
        ) -> Self {
            Self {
                id,
                coin_metadata_object,
                deny_cap_object,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey
    for RegulatedCoinMetadata<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Capability allowing the bearer to mint and burn
    /// coins of type `T`. Transferable
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct TreasuryCap<T> {
        pub id: super::object::UID,
        pub total_supply: super::balance::Supply<T>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TreasuryCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            total_supply: super::balance::Supply<T>,
        ) -> Self {
            Self {
                id,
                total_supply,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for TreasuryCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Capability allowing the bearer to deny addresses from using the currency's coins--
    /// immediately preventing those addresses from interacting with the coin as an input to a
    /// transaction and at the start of the next preventing them from receiving the coin.
    /// If `allow_global_pause` is true, the bearer can enable a global pause that behaves as if
    /// all addresses were added to the deny list.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct DenyCapV2<T> {
        pub id: super::object::UID,
        pub allow_global_pause: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DenyCapV2<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, allow_global_pause: bool) -> Self {
            Self {
                id,
                allow_global_pause,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for DenyCapV2<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct CurrencyCreated<T> {
        pub decimals: u8,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> CurrencyCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(decimals: u8) -> Self {
            Self {
                decimals,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    /// Capability allowing the bearer to freeze addresses, preventing those addresses from
    /// interacting with the coin as an input to a transaction.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct DenyCap<T> {
        pub id: super::object::UID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DenyCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for DenyCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod config {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct Config<WriteCap> {
        pub id: super::object::UID,
        #[serde(skip)]
        _WriteCap: ::std::marker::PhantomData<WriteCap>,
    }
    impl<WriteCap> Config<WriteCap> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self {
                id,
                _WriteCap: ::std::marker::PhantomData,
            }
        }
    }
    impl<WriteCap: ::moverox::traits::MoveType> ::moverox::traits::HasKey
    for Config<WriteCap> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct Setting<Value> {
        pub data: Option<SettingData<Value>>,
    }
    impl<Value> Setting<Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(data: Option<SettingData<Value>>) -> Self {
            Self { data }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct SettingData<Value> {
        pub newer_value_epoch: u64,
        pub newer_value: Option<Value>,
        pub older_value_opt: Option<Value>,
    }
    impl<Value> SettingData<Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            newer_value_epoch: u64,
            newer_value: Option<Value>,
            older_value_opt: Option<Value>,
        ) -> Self {
            Self {
                newer_value_epoch,
                newer_value,
                older_value_opt,
            }
        }
    }
}
/// Defines the `DenyList` type. The `DenyList` shared object is used to restrict access to
/// instances of certain core types from being used as inputs by specified addresses in the deny
/// list.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod deny_list {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A shared object that stores the addresses that are blocked for a given core type.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct DenyList {
        pub id: super::object::UID,
        /// The individual deny lists.
        pub lists: super::bag::Bag,
    }
    impl DenyList {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, lists: super::bag::Bag) -> Self {
            Self { id, lists }
        }
    }
    impl ::moverox::traits::HasKey for DenyList {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// The capability used to write to the deny list config. Ensures that the Configs for the
    /// DenyList are modified only by this module.
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct ConfigWriteCap(bool);
    impl ConfigWriteCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
    /// The dynamic object field key used to store the `Config` for a given type, essentially a
    /// `(per_type_index, per_type_key)` pair.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct ConfigKey {
        pub per_type_index: u64,
        pub per_type_key: vector<u8>,
    }
    impl ConfigKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(per_type_index: u64, per_type_key: vector<u8>) -> Self {
            Self {
                per_type_index,
                per_type_key,
            }
        }
    }
    /// The setting key used to store the deny list for a given address in the `Config`.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct AddressKey(pub address);
    impl AddressKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: address) -> Self {
            Self(_0)
        }
    }
    /// The setting key used to store the global pause setting in the `Config`.
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct GlobalPauseKey(bool);
    impl GlobalPauseKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
    /// The event emitted when a new `Config` is created for a given type. This can be useful for
    /// tracking the `ID` of a type's `Config` object.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct PerTypeConfigCreated {
        pub key: ConfigKey,
        pub config_id: super::object::ID,
    }
    impl PerTypeConfigCreated {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(key: ConfigKey, config_id: super::object::ID) -> Self {
            Self { key, config_id }
        }
    }
    /// Stores the addresses that are denied for a given core type.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct PerTypeList {
        pub id: super::object::UID,
        /// Number of object types that have been banned for a given address.
        /// Used to quickly skip checks for most addresses.
        pub denied_count: super::table::Table<address, u64>,
        /// Set of addresses that are banned for a given type.
        /// For example with `sui::coin::Coin`: If addresses A and B are banned from using
        /// "0...0123::my_coin::MY_COIN", this will be "0...0123::my_coin::MY_COIN" -> {A, B}.
        pub denied_addresses: super::table::Table<
            vector<u8>,
            super::vec_set::VecSet<address>,
        >,
    }
    impl PerTypeList {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            denied_count: super::table::Table<address, u64>,
            denied_addresses: super::table::Table<
                vector<u8>,
                super::vec_set::VecSet<address>,
            >,
        ) -> Self {
            Self {
                id,
                denied_count,
                denied_addresses,
            }
        }
    }
    impl ::moverox::traits::HasKey for PerTypeList {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// Defines a Display struct which defines the way an Object
/// should be displayed. The intention is to keep data as independent
/// from its display as possible, protecting the development process
/// and keeping it separate from the ecosystem agreements.
///
/// Each of the fields of the Display object should allow for pattern
/// substitution and filling-in the pieces using the data from the object T.
///
/// More entry functions might be added in the future depending on the use cases.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod display {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// The Display<T> object. Defines the way a T instance should be
    /// displayed. Display object can only be created and modified with
    /// a PublisherCap, making sure that the rules are set by the owner
    /// of the type.
    ///
    /// Each of the display properties should support patterns outside
    /// of the system, making it simpler to customize Display based
    /// on the property values of an Object.
    /// ```
    /// // Example of a display object
    /// Display<0x...::capy::Capy> {
    ///  fields:
    ///    <name, "Capy { genes }">
    ///    <link, "https://capy.art/capy/{ id }">
    ///    <image, "https://api.capy.art/capy/{ id }/svg">
    ///    <description, "Lovely Capy, one of many">
    /// }
    /// ```
    ///
    /// Uses only String type due to external-facing nature of the object,
    /// the property names have a priority over their types.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct Display<T> {
        pub id: super::object::UID,
        /// Contains fields for display. Currently supported
        /// fields are: name, link, image and description.
        pub fields: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            ::moverox_sui::std::string::String,
        >,
        /// Version that can only be updated manually by the Publisher.
        pub version: u16,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Display<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            fields: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                ::moverox_sui::std::string::String,
            >,
            version: u16,
        ) -> Self {
            Self {
                id,
                fields,
                version,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for Display<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Event: emitted when a new Display object has been created for type T.
    /// Type signature of the event corresponds to the type while id serves for
    /// the discovery.
    ///
    /// Since Sui RPC supports querying events by type, finding a Display for the T
    /// would be as simple as looking for the first event with `Display<T>`.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct DisplayCreated<T> {
        pub id: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DisplayCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    /// Version of Display got updated -
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct VersionUpdated<T> {
        pub id: super::object::ID,
        pub version: u16,
        pub fields: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            ::moverox_sui::std::string::String,
        >,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> VersionUpdated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::ID,
            version: u16,
            fields: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                ::moverox_sui::std::string::String,
            >,
        ) -> Self {
            Self {
                id,
                version,
                fields,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
/// In addition to the fields declared in its type definition, a Sui object can have dynamic fields
/// that can be added after the object has been constructed. Unlike ordinary field names
/// (which are always statically declared identifiers) a dynamic field name can be any value with
/// the `copy`, `drop`, and `store` abilities, e.g. an integer, a boolean, or a string.
/// This gives Sui programmers the flexibility to extend objects on-the-fly, and it also serves as a
/// building block for core collection types
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod dynamic_field {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Internal object used for storing the field and value
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = dynamic_field)]
    #[allow(non_snake_case)]
    pub struct Field<Name, Value> {
        /// Determined by the hash of the object ID, the field name value and it's type,
        /// i.e. hash(parent.id || name || Name)
        pub id: super::object::UID,
        /// The value for the name of this field
        pub name: Name,
        /// The value bound to this field
        pub value: Value,
    }
    impl<Name, Value> Field<Name, Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, name: Name, value: Value) -> Self {
            Self { id, name, value }
        }
    }
    impl<
        Name: ::moverox::traits::MoveType,
        Value: ::moverox::traits::MoveType,
    > ::moverox::traits::HasKey for Field<Name, Value> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// Similar to `sui::dynamic_field`, this module allows for the access of dynamic fields. But
/// unlike, `sui::dynamic_field` the values bound to these dynamic fields _must_ be objects
/// themselves. This allows for the objects to still exist within in storage, which may be important
/// for external tools. The difference is otherwise not observable from within Move.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod dynamic_object_field {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = dynamic_object_field)]
    #[allow(non_snake_case)]
    pub struct Wrapper<Name> {
        pub name: Name,
    }
    impl<Name> Wrapper<Name> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(name: Name) -> Self {
            Self { name }
        }
    }
}
/// Similar to `sui::table` but the values are linked together, allowing for ordered insertion and
/// removal
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod linked_table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = linked_table)]
    #[allow(non_snake_case)]
    pub struct LinkedTable<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        /// the front of the table, i.e. the key of the first entry
        pub head: Option<K>,
        /// the back of the table, i.e. the key of the last entry
        pub tail: Option<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> LinkedTable<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            size: u64,
            head: Option<K>,
            tail: Option<K>,
        ) -> Self {
            Self {
                id,
                size,
                head,
                tail,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        K: ::moverox::traits::MoveType,
        V: ::moverox::traits::MoveType,
    > ::moverox::traits::HasKey for LinkedTable<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = linked_table)]
    #[allow(non_snake_case)]
    pub struct Node<K, V> {
        /// the previous key
        pub prev: Option<K>,
        /// the next key
        pub next: Option<K>,
        /// the value being stored
        pub value: V,
    }
    impl<K, V> Node<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(prev: Option<K>, next: Option<K>, value: V) -> Self {
            Self { prev, next, value }
        }
    }
}
/// Sui object identifiers
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod object {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// An object ID. This is used to reference Sui Objects.
    /// This is *not* guaranteed to be globally unique--anyone can create an `ID` from a `UID` or
    /// from an object, and ID's can be freely copied and dropped.
    /// Here, the values are not globally unique because there can be multiple values of type `ID`
    /// with the same underlying bytes. For example, `object::id(&obj)` can be called as many times
    /// as you want for a given `obj`, and each `ID` value will be identical.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object)]
    #[allow(non_snake_case)]
    pub struct ID {
        pub bytes: address,
    }
    impl ID {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: address) -> Self {
            Self { bytes }
        }
    }
    /// Globally unique IDs that define an object's ID in storage. Any Sui Object, that is a struct
    /// with the `key` ability, must have `id: UID` as its first field.
    /// These are globally unique in the sense that no two values of type `UID` are ever equal, in
    /// other words for any two values `id1: UID` and `id2: UID`, `id1` != `id2`.
    /// This is a privileged type that can only be derived from a `TxContext`.
    /// `UID` doesn't have the `drop` ability, so deleting a `UID` requires a call to `delete`.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object)]
    #[allow(non_snake_case)]
    pub struct UID {
        pub id: super::object::ID,
    }
    impl UID {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self { id }
        }
    }
}
/// Similar to `sui::bag`, an `ObjectBag` is a heterogeneous map-like collection. But unlike
/// `sui::bag`, the values bound to these dynamic fields _must_ be objects themselves. This allows
/// for the objects to still exist in storage, which may be important for external tools.
/// The difference is otherwise not observable from within Move.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod object_bag {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object_bag)]
    #[allow(non_snake_case)]
    pub struct ObjectBag {
        /// the ID of this bag
        pub id: super::object::UID,
        /// the number of key-value pairs in the bag
        pub size: u64,
    }
    impl ObjectBag {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self { id, size }
        }
    }
    impl ::moverox::traits::HasKey for ObjectBag {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// Similar to `sui::table`, an `ObjectTable<K, V>` is a map-like collection. But unlike
/// `sui::table`, the values bound to these dynamic fields _must_ be objects themselves. This allows
/// for the objects to still exist within in storage, which may be important for external tools.
/// The difference is otherwise not observable from within Move.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod object_table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object_table)]
    #[allow(non_snake_case)]
    pub struct ObjectTable<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        #[serde(skip)]
        _K: ::std::marker::PhantomData<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> ObjectTable<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self {
                id,
                size,
                _K: ::std::marker::PhantomData,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        K: ::moverox::traits::MoveType,
        V: ::moverox::traits::MoveType,
    > ::moverox::traits::HasKey for ObjectTable<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// Functions for operating on Move packages from within Move:
/// - Creating proof-of-publish objects from one-time witnesses
/// - Administering package upgrades through upgrade policies.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod package {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// This type can only be created in the transaction that
    /// generates a module, by consuming its one-time witness, so it
    /// can be used to identify the address that published the package
    /// a type originated from.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct Publisher {
        pub id: super::object::UID,
        pub package: ::moverox_sui::std::ascii::String,
        pub module_name: ::moverox_sui::std::ascii::String,
    }
    impl Publisher {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            package: ::moverox_sui::std::ascii::String,
            module_name: ::moverox_sui::std::ascii::String,
        ) -> Self {
            Self { id, package, module_name }
        }
    }
    impl ::moverox::traits::HasKey for Publisher {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Capability controlling the ability to upgrade a package.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeCap {
        pub id: super::object::UID,
        /// (Mutable) ID of the package that can be upgraded.
        pub package: super::object::ID,
        /// (Mutable) The number of upgrades that have been applied
        /// successively to the original package.  Initially 0.
        pub version: u64,
        /// What kind of upgrades are allowed.
        pub policy: u8,
    }
    impl UpgradeCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            package: super::object::ID,
            version: u64,
            policy: u8,
        ) -> Self {
            Self {
                id,
                package,
                version,
                policy,
            }
        }
    }
    impl ::moverox::traits::HasKey for UpgradeCap {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Permission to perform a particular upgrade (for a fixed version of
    /// the package, bytecode to upgrade with and transitive dependencies to
    /// depend against).
    ///
    /// An `UpgradeCap` can only issue one ticket at a time, to prevent races
    /// between concurrent updates or a change in its upgrade policy after
    /// issuing a ticket, so the ticket is a "Hot Potato" to preserve forward
    /// progress.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeTicket {
        /// (Immutable) ID of the `UpgradeCap` this originated from.
        pub cap: super::object::ID,
        /// (Immutable) ID of the package that can be upgraded.
        pub package: super::object::ID,
        /// (Immutable) The policy regarding what kind of upgrade this ticket
        /// permits.
        pub policy: u8,
        /// (Immutable) SHA256 digest of the bytecode and transitive
        /// dependencies that will be used in the upgrade.
        pub digest: vector<u8>,
    }
    impl UpgradeTicket {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            cap: super::object::ID,
            package: super::object::ID,
            policy: u8,
            digest: vector<u8>,
        ) -> Self {
            Self {
                cap,
                package,
                policy,
                digest,
            }
        }
    }
    /// Issued as a result of a successful upgrade, containing the
    /// information to be used to update the `UpgradeCap`.  This is a "Hot
    /// Potato" to ensure that it is used to update its `UpgradeCap` before
    /// the end of the transaction that performed the upgrade.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeReceipt {
        /// (Immutable) ID of the `UpgradeCap` this originated from.
        pub cap: super::object::ID,
        /// (Immutable) ID of the package after it was upgraded.
        pub package: super::object::ID,
    }
    impl UpgradeReceipt {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(cap: super::object::ID, package: super::object::ID) -> Self {
            Self { cap, package }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod party {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// The permissions that apply to a party object. If the transaction sender has an entry in
    /// the `members` map, the permissions in that entry apply. Otherwise, the `default` permissions
    /// are used.
    /// If the party has the `READ` permission, the object can be taken as an immutable input.
    /// If the party has the `WRITE`, `DELETE`, or `TRANSFER` permissions, the object can be taken as
    /// a mutable input. Additional restrictions pertaining to each permission are checked at the end
    /// of transaction execution.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = party)]
    #[allow(non_snake_case)]
    pub struct Party {
        /// The permissions that apply if no specific permissions are set in the `members` map.
        pub default: Permissions,
        /// The permissions per transaction sender.
        pub members: super::vec_map::VecMap<address, Permissions>,
    }
    impl Party {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            default: Permissions,
            members: super::vec_map::VecMap<address, Permissions>,
        ) -> Self {
            Self { default, members }
        }
    }
    /// The permissions that a party has. The permissions are a bitset of the `READ`, `WRITE`,
    /// `DELETE`, and `TRANSFER` constants.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = party)]
    #[allow(non_snake_case)]
    pub struct Permissions(pub u64);
    impl Permissions {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: u64) -> Self {
            Self(_0)
        }
    }
}
/// Priority queue implemented using a max heap.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod priority_queue {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Struct representing a priority queue. The `entries` vector represents a max
    /// heap structure, where entries[0] is the root, entries[1] and entries[2] are the
    /// left child and right child of the root, etc. More generally, the children of
    /// entries[i] are at i * 2 + 1 and i * 2 + 2. The max heap should have the invariant
    /// that the parent node's priority is always higher than its child nodes' priorities.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = priority_queue)]
    #[allow(non_snake_case)]
    pub struct PriorityQueue<T> {
        pub entries: vector<Entry<T>>,
    }
    impl<T> PriorityQueue<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(entries: vector<Entry<T>>) -> Self {
            Self { entries }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = priority_queue)]
    #[allow(non_snake_case)]
    pub struct Entry<T> {
        pub priority: u64,
        pub value: T,
    }
    impl<T> Entry<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(priority: u64, value: T) -> Self {
            Self { priority, value }
        }
    }
}
/// This module provides functionality for generating secure randomness.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod random {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Singleton shared object which stores the global randomness state.
    /// The actual state is stored in a versioned inner field.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct Random {
        pub id: super::object::UID,
        pub inner: super::versioned::Versioned,
    }
    impl Random {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            inner: super::versioned::Versioned,
        ) -> Self {
            Self { id, inner }
        }
    }
    impl ::moverox::traits::HasKey for Random {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct RandomInner {
        pub version: u64,
        pub epoch: u64,
        pub randomness_round: u64,
        pub random_bytes: vector<u8>,
    }
    impl RandomInner {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            version: u64,
            epoch: u64,
            randomness_round: u64,
            random_bytes: vector<u8>,
        ) -> Self {
            Self {
                version,
                epoch,
                randomness_round,
                random_bytes,
            }
        }
    }
    /// Unique randomness generator, derived from the global randomness.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct RandomGenerator {
        pub seed: vector<u8>,
        pub counter: u16,
        pub buffer: vector<u8>,
    }
    impl RandomGenerator {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(seed: vector<u8>, counter: u16, buffer: vector<u8>) -> Self {
            Self { seed, counter, buffer }
        }
    }
}
/// Coin<SUI> is the token used to pay for gas in Sui.
/// It has 9 decimals, and the smallest unit (10^-9) is called "mist".
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod sui {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Name of the coin
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = sui)]
    #[allow(non_snake_case)]
    pub struct SUI {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl SUI {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
}
/// A table is a map-like collection. But unlike a traditional collection, it's keys and values are
/// not stored within the `Table` value, but instead are stored using Sui's object system. The
/// `Table` struct acts only as a handle into the object system to retrieve those keys and values.
/// Note that this means that `Table` values with exactly the same key-value mapping will not be
/// equal, with `==`, at runtime. For example
/// ```
/// let table1 = table::new<u64, bool>();
/// let table2 = table::new<u64, bool>();
/// table::add(&mut table1, 0, false);
/// table::add(&mut table1, 1, true);
/// table::add(&mut table2, 0, false);
/// table::add(&mut table2, 1, true);
/// // table1 does not equal table2, despite having the same entries
/// assert!(&table1 != &table2);
/// ```
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = table)]
    #[allow(non_snake_case)]
    pub struct Table<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        #[serde(skip)]
        _K: ::std::marker::PhantomData<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> Table<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self {
                id,
                size,
                _K: ::std::marker::PhantomData,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<
        K: ::moverox::traits::MoveType,
        V: ::moverox::traits::MoveType,
    > ::moverox::traits::HasKey for Table<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
/// A basic scalable vector library implemented using `Table`.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod table_vec {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = table_vec)]
    #[allow(non_snake_case)]
    pub struct TableVec<Element> {
        /// The contents of the table vector.
        pub contents: super::table::Table<u64, Element>,
        #[serde(skip)]
        _Element: ::std::marker::PhantomData<Element>,
    }
    impl<Element> TableVec<Element> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: super::table::Table<u64, Element>) -> Self {
            Self {
                contents,
                _Element: ::std::marker::PhantomData,
            }
        }
    }
}
/// The Token module which implements a Closed Loop Token with a configurable
/// policy. The policy is defined by a set of rules that must be satisfied for
/// an action to be performed on the token.
///
/// The module is designed to be used with a `TreasuryCap` to allow for minting
/// and burning of the `Token`s. And can act as a replacement / extension or a
/// companion to existing open-loop (`Coin`) systems.
///
/// ```
/// Module:      sui::balance       sui::coin             sui::token
/// Main type:   Balance<T>         Coin<T>               Token<T>
/// Capability:  Supply<T>  <---->  TreasuryCap<T> <----> TreasuryCap<T>
/// Abilities:   store              key + store           key
/// ```
///
/// The Token system allows for fine-grained control over the actions performed
/// on the token. And hence it is highly suitable for applications that require
/// control over the currency which a simple open-loop system can't provide.
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod token {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A single `Token` with `Balance` inside. Can only be owned by an address,
    /// and actions performed on it must be confirmed in a matching `TokenPolicy`.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct Token<T> {
        pub id: super::object::UID,
        /// The Balance of the `Token`.
        pub balance: super::balance::Balance<T>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Token<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            balance: super::balance::Balance<T>,
        ) -> Self {
            Self {
                id,
                balance,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for Token<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// A Capability that manages a single `TokenPolicy` specified in the `for`
    /// field. Created together with `TokenPolicy` in the `new` function.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicyCap<T> {
        pub id: super::object::UID,
        pub r#for: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicyCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, r#for: super::object::ID) -> Self {
            Self {
                id,
                r#for,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey
    for TokenPolicyCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// `TokenPolicy` represents a set of rules that define what actions can be
    /// performed on a `Token` and which `Rules` must be satisfied for the
    /// action to succeed.
    ///
    /// - For the sake of availability, `TokenPolicy` is a `key`-only object.
    /// - Each `TokenPolicy` is managed by a matching `TokenPolicyCap`.
    /// - For an action to become available, there needs to be a record in the
    /// `rules` VecMap. To allow an action to be performed freely, there's an
    /// `allow` function that can be called by the `TokenPolicyCap` owner.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicy<T> {
        pub id: super::object::UID,
        /// The balance that is effectively spent by the user on the "spend"
        /// action. However, actual decrease of the supply can only be done by
        /// the `TreasuryCap` owner when `flush` is called.
        ///
        /// This balance is effectively spent and cannot be accessed by anyone
        /// but the `TreasuryCap` owner.
        pub spent_balance: super::balance::Balance<T>,
        /// The set of rules that define what actions can be performed on the
        /// token. For each "action" there's a set of Rules that must be
        /// satisfied for the `ActionRequest` to be confirmed.
        pub rules: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        >,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicy<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            spent_balance: super::balance::Balance<T>,
            rules: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
            >,
        ) -> Self {
            Self {
                id,
                spent_balance,
                rules,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T: ::moverox::traits::MoveType> ::moverox::traits::HasKey for TokenPolicy<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// A request to perform an "Action" on a token. Stores the information
    /// about the action to be performed and must be consumed by the `confirm_request`
    /// or `confirm_request_mut` functions when the Rules are satisfied.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct ActionRequest<T> {
        /// Name of the Action to look up in the Policy. Name can be one of the
        /// default actions: `transfer`, `spend`, `to_coin`, `from_coin` or a
        /// custom action.
        pub name: ::moverox_sui::std::string::String,
        /// Amount is present in all of the txs
        pub amount: u64,
        /// Sender is a permanent field always
        pub sender: address,
        /// Recipient is only available in `transfer` action.
        pub recipient: Option<address>,
        /// The balance to be "spent" in the `TokenPolicy`, only available
        /// in the `spend` action.
        pub spent_balance: Option<super::balance::Balance<T>>,
        /// Collected approvals (stamps) from completed `Rules`. They're matched
        /// against `TokenPolicy.rules` to determine if the request can be
        /// confirmed.
        pub approvals: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> ActionRequest<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            name: ::moverox_sui::std::string::String,
            amount: u64,
            sender: address,
            recipient: Option<address>,
            spent_balance: Option<super::balance::Balance<T>>,
            approvals: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        ) -> Self {
            Self {
                name,
                amount,
                sender,
                recipient,
                spent_balance,
                approvals,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    /// Dynamic field key for the `TokenPolicy` to store the `Config` for a
    /// specific action `Rule`. There can be only one configuration per
    /// `Rule` per `TokenPolicy`.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct RuleKey<T> {
        pub is_protected: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> RuleKey<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(is_protected: bool) -> Self {
            Self {
                is_protected,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    /// An event emitted when a `TokenPolicy` is created and shared. Because
    /// `TokenPolicy` can only be shared (and potentially frozen in the future),
    /// we emit this event in the `share_policy` function and mark it as mutable.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicyCreated<T> {
        /// ID of the `TokenPolicy` that was created.
        pub id: super::object::ID,
        /// Whether the `TokenPolicy` is "shared" (mutable) or "frozen"
        /// (immutable) - TBD.
        pub is_mutable: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicyCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID, is_mutable: bool) -> Self {
            Self {
                id,
                is_mutable,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod transfer {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// This represents the ability to `receive` an object of type `T`.
    /// This type is ephemeral per-transaction and cannot be stored on-chain.
    /// This does not represent the obligation to receive the object that it
    /// references, but simply the ability to receive the object with object ID
    /// `id` at version `version` if you can prove mutable access to the parent
    /// object during the transaction.
    /// Internals of this struct are opaque outside this module.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer)]
    #[allow(non_snake_case)]
    pub struct Receiving<T> {
        pub id: super::object::ID,
        pub version: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Receiving<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID, version: u64) -> Self {
            Self {
                id,
                version,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod tx_context {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Information about the transaction currently being executed.
    /// This cannot be constructed by a transaction--it is a privileged object created by
    /// the VM and passed in to the entrypoint of the transaction as `&mut TxContext`.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = tx_context)]
    #[allow(non_snake_case)]
    pub struct TxContext {
        /// The address of the user that signed the current transaction
        pub sender: address,
        /// Hash of the current transaction
        pub tx_hash: vector<u8>,
        /// The current epoch number
        pub epoch: u64,
        /// Timestamp that the epoch started at
        pub epoch_timestamp_ms: u64,
        /// Counter recording the number of fresh id's created while executing
        /// this transaction. Always 0 at the start of a transaction
        pub ids_created: u64,
    }
    impl TxContext {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            sender: address,
            tx_hash: vector<u8>,
            epoch: u64,
            epoch_timestamp_ms: u64,
            ids_created: u64,
        ) -> Self {
            Self {
                sender,
                tx_hash,
                epoch,
                epoch_timestamp_ms,
                ids_created,
            }
        }
    }
}
/// URL: standard Uniform Resource Locator string
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod url {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// Standard Uniform Resource Locator (URL) string.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = url)]
    #[allow(non_snake_case)]
    pub struct Url {
        pub url: ::moverox_sui::std::ascii::String,
    }
    impl Url {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(url: ::moverox_sui::std::ascii::String) -> Self {
            Self { url }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod vec_map {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A map data structure backed by a vector. The map is guaranteed not to contain duplicate keys, but entries
    /// are *not* sorted by key--entries are included in insertion order.
    /// All operations are O(N) in the size of the map--the intention of this data structure is only to provide
    /// the convenience of programming against a map API.
    /// Large maps should use handwritten parent/child relationships instead.
    /// Maps that need sorted iteration rather than insertion order iteration should also be handwritten.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_map)]
    #[allow(non_snake_case)]
    pub struct VecMap<K, V> {
        pub contents: vector<Entry<K, V>>,
    }
    impl<K, V> VecMap<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: vector<Entry<K, V>>) -> Self {
            Self { contents }
        }
    }
    /// An entry in the map
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_map)]
    #[allow(non_snake_case)]
    pub struct Entry<K, V> {
        pub key: K,
        pub value: V,
    }
    impl<K, V> Entry<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(key: K, value: V) -> Self {
            Self { key, value }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod vec_set {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A set data structure backed by a vector. The set is guaranteed not to
    /// contain duplicate keys. All operations are O(N) in the size of the set
    /// - the intention of this data structure is only to provide the convenience
    /// of programming against a set API. Sets that need sorted iteration rather
    /// than insertion order iteration should be handwritten.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_set)]
    #[allow(non_snake_case)]
    pub struct VecSet<K> {
        pub contents: vector<K>,
    }
    impl<K> VecSet<K> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: vector<K>) -> Self {
            Self { contents }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod versioned {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    /// A wrapper type that supports versioning of the inner type.
    /// The inner type is a dynamic field of the Versioned object, and is keyed using version.
    /// User of this type could load the inner object using corresponding type based on the version.
    /// You can also upgrade the inner object to a new type version.
    /// If you want to support lazy upgrade of the inner type, one caveat is that all APIs would have
    /// to use mutable reference even if it's a read-only API.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = versioned)]
    #[allow(non_snake_case)]
    pub struct Versioned {
        pub id: super::object::UID,
        pub version: u64,
    }
    impl Versioned {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, version: u64) -> Self {
            Self { id, version }
        }
    }
    impl ::moverox::traits::HasKey for Versioned {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    /// Represents a hot potato object generated when we take out the dynamic field.
    /// This is to make sure that we always put a new value back.
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = versioned)]
    #[allow(non_snake_case)]
    pub struct VersionChangeCap {
        pub versioned_id: super::object::ID,
        pub old_version: u64,
    }
    impl VersionChangeCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(versioned_id: super::object::ID, old_version: u64) -> Self {
            Self { versioned_id, old_version }
        }
    }
}
