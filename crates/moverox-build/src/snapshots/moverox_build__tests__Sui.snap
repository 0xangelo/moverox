---
source: crates/moverox-build/src/tests.rs
expression: sui_framework
---
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod accumulator {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = accumulator)]
    #[allow(non_snake_case)]
    pub struct AccumulatorRoot {
        pub id: super::object::UID,
    }
    impl AccumulatorRoot {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self { id }
        }
    }
    impl ::moverox::traits::HasKey for AccumulatorRoot {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod authenticator_state {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Singleton shared object which stores the global authenticator state."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The actual state is stored in a dynamic field of type AuthenticatorStateInner to support"
    )]
    #[cfg_attr(not(doctest), doc = " future versions of the authenticator state.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct AuthenticatorState {
        pub id: super::object::UID,
        pub version: u64,
    }
    impl AuthenticatorState {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, version: u64) -> Self {
            Self { id, version }
        }
    }
    impl ::moverox::traits::HasKey for AuthenticatorState {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct AuthenticatorStateInner {
        pub version: u64,
        /// List of currently active JWKs.
        pub active_jwks: vector<ActiveJwk>,
    }
    impl AuthenticatorStateInner {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(version: u64, active_jwks: vector<ActiveJwk>) -> Self {
            Self { version, active_jwks }
        }
    }
    #[cfg_attr(not(doctest), doc = " Must match the JWK struct in fastcrypto-zkp")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct JWK {
        pub kty: ::moverox_sui::std::string::String,
        pub e: ::moverox_sui::std::string::String,
        pub n: ::moverox_sui::std::string::String,
        pub alg: ::moverox_sui::std::string::String,
    }
    impl JWK {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            kty: ::moverox_sui::std::string::String,
            e: ::moverox_sui::std::string::String,
            n: ::moverox_sui::std::string::String,
            alg: ::moverox_sui::std::string::String,
        ) -> Self {
            Self { kty, e, n, alg }
        }
    }
    #[cfg_attr(not(doctest), doc = " Must match the JwkId struct in fastcrypto-zkp")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct JwkId {
        pub iss: ::moverox_sui::std::string::String,
        pub kid: ::moverox_sui::std::string::String,
    }
    impl JwkId {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            iss: ::moverox_sui::std::string::String,
            kid: ::moverox_sui::std::string::String,
        ) -> Self {
            Self { iss, kid }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = authenticator_state)]
    #[allow(non_snake_case)]
    pub struct ActiveJwk {
        pub jwk_id: JwkId,
        pub jwk: JWK,
        pub epoch: u64,
    }
    impl ActiveJwk {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(jwk_id: JwkId, jwk: JWK, epoch: u64) -> Self {
            Self { jwk_id, jwk, epoch }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A bag is a heterogeneous map-like collection. The collection is similar to `sui::table` in that"
)]
#[cfg_attr(
    not(doctest),
    doc = " its keys and values are not stored within the `Bag` value, but instead are stored using Sui's"
)]
#[cfg_attr(
    not(doctest),
    doc = " object system. The `Bag` struct acts only as a handle into the object system to retrieve those"
)]
#[cfg_attr(not(doctest), doc = " keys and values.")]
#[cfg_attr(
    not(doctest),
    doc = " Note that this means that `Bag` values with exactly the same key-value mapping will not be"
)]
#[cfg_attr(not(doctest), doc = " equal, with `==`, at runtime. For example")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = " let bag1 = bag::new();")]
#[cfg_attr(not(doctest), doc = " let bag2 = bag::new();")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag1, 0, false);")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag1, 1, true);")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag2, 0, false);")]
#[cfg_attr(not(doctest), doc = " bag::add(&mut bag2, 1, true);")]
#[cfg_attr(
    not(doctest),
    doc = " // bag1 does not equal bag2, despite having the same entries"
)]
#[cfg_attr(not(doctest), doc = " assert!(&bag1 != &bag2);")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(
    not(doctest),
    doc = " At it's core, `sui::bag` is a wrapper around `UID` that allows for access to"
)]
#[cfg_attr(
    not(doctest),
    doc = " `sui::dynamic_field` while preventing accidentally stranding field values. A `UID` can be"
)]
#[cfg_attr(
    not(doctest),
    doc = " deleted, even if it has dynamic fields associated with it, but a bag, on the other hand, must be"
)]
#[cfg_attr(not(doctest), doc = " empty to be destroyed.")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod bag {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bag)]
    #[allow(non_snake_case)]
    pub struct Bag {
        /// the ID of this bag
        pub id: super::object::UID,
        /// the number of key-value pairs in the bag
        pub size: u64,
    }
    impl Bag {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self { id, size }
        }
    }
    impl ::moverox::traits::HasKey for Bag {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A storable handler for Balances in general. Is used in the `Coin`"
)]
#[cfg_attr(
    not(doctest),
    doc = " module to allow balance operations and can be used to implement"
)]
#[cfg_attr(not(doctest), doc = " custom coins with `Supply` and `Balance`s.")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod balance {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " A Supply of T. Used for minting and burning.")]
    #[cfg_attr(
        not(doctest),
        doc = " Wrapped into a `TreasuryCap` in the `Coin` module."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = balance)]
    #[allow(non_snake_case)]
    pub struct Supply<T> {
        pub value: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Supply<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u64) -> Self {
            Self {
                value,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Storable balance - an inner struct of a Coin type."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Can be used to store coins which don't need the key ability."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = balance)]
    #[allow(non_snake_case)]
    pub struct Balance<T> {
        pub value: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Balance<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u64) -> Self {
            Self {
                value,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(not(doctest), doc = " This module implements BCS (de)serialization in Move.")]
#[cfg_attr(
    not(doctest),
    doc = " Full specification can be found here: https://github.com/diem/bcs"
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " Short summary (for Move-supported types):")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " - address - sequence of X bytes")]
#[cfg_attr(not(doctest), doc = " - bool - byte with 0 or 1")]
#[cfg_attr(not(doctest), doc = " - u8 - a single u8 byte")]
#[cfg_attr(not(doctest), doc = " - u16 / u32 / u64 / u128 / u256 - LE bytes")]
#[cfg_attr(not(doctest), doc = " - vector - ULEB128 length + LEN elements")]
#[cfg_attr(
    not(doctest),
    doc = " - option - first byte bool: None (0) or Some (1), then value"
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " Usage example:")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(
    not(doctest),
    doc = " /// This function reads u8 and u64 value from the input"
)]
#[cfg_attr(not(doctest), doc = " /// and returns the rest of the bytes.")]
#[cfg_attr(
    not(doctest),
    doc = " fun deserialize(bytes: vector<u8>): (u8, u64, vector<u8>) {"
)]
#[cfg_attr(not(doctest), doc = "     use sui::bcs::{Self, BCS};")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = "     let prepared: BCS = bcs::new(bytes);")]
#[cfg_attr(not(doctest), doc = "     let (u8_value, u64_value) = (")]
#[cfg_attr(not(doctest), doc = "         prepared.peel_u8(),")]
#[cfg_attr(not(doctest), doc = "         prepared.peel_u64()")]
#[cfg_attr(not(doctest), doc = "     );")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = "     // unpack bcs struct")]
#[cfg_attr(not(doctest), doc = "     let leftovers = prepared.into_remainder_bytes();")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = "     (u8_value, u64_value, leftovers)")]
#[cfg_attr(not(doctest), doc = " }")]
#[cfg_attr(not(doctest), doc = " ```")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod bcs {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A helper struct that saves resources on operations. For better"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " vector performance, it stores reversed bytes of the BCS and"
    )]
    #[cfg_attr(not(doctest), doc = " enables use of `vector::pop_back`.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = bcs)]
    #[allow(non_snake_case)]
    pub struct BCS {
        pub bytes: vector<u8>,
    }
    impl BCS {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self { bytes }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A simple library that enables hot-potato-locked borrow mechanics."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " With Programmable transactions, it is possible to borrow a value within"
)]
#[cfg_attr(
    not(doctest),
    doc = " a transaction, use it and put back in the end. Hot-potato `Borrow` makes"
)]
#[cfg_attr(
    not(doctest),
    doc = " sure the object is returned and was not swapped for another one."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod borrow {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " An object wrapping a `T` and providing the borrow API."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Referent<T> {
        pub id: address,
        pub value: Option<T>,
    }
    impl<T> Referent<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: address, value: Option<T>) -> Self {
            Self { id, value }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A hot potato making sure the object is put back once borrowed."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Borrow {
        pub r#ref: address,
        pub obj: super::object::ID,
    }
    impl Borrow {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(r#ref: address, obj: super::object::ID) -> Self {
            Self { r#ref, obj }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = borrow)]
    #[allow(non_snake_case)]
    pub struct Test {
        pub id: super::object::UID,
    }
    impl Test {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self { id }
        }
    }
    impl ::moverox::traits::HasKey for Test {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " APIs for accessing time from move calls, via the `Clock`: a unique"
)]
#[cfg_attr(not(doctest), doc = " shared object that is created at 0x6 during genesis.")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod clock {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Singleton shared object that exposes time to Move calls.  This"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " object is found at address 0x6, and can only be read (accessed"
    )]
    #[cfg_attr(not(doctest), doc = " via an immutable reference) by entry functions.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Entry Functions that attempt to accept `Clock` by mutable"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " reference or value will fail to verify, and honest validators"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " will not sign or execute transactions that use `Clock` as an"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " input parameter, unless it is passed by immutable reference."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = clock)]
    #[allow(non_snake_case)]
    pub struct Clock {
        pub id: super::object::UID,
        /// The clock's timestamp, which is set automatically by a
        /// system transaction every time consensus commits a
        /// schedule, or by `sui::clock::increment_for_testing` during
        /// testing.
        pub timestamp_ms: u64,
    }
    impl Clock {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, timestamp_ms: u64) -> Self {
            Self { id, timestamp_ms }
        }
    }
    impl ::moverox::traits::HasKey for Clock {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines the `Coin` type - platform wide representation of fungible"
)]
#[cfg_attr(
    not(doctest),
    doc = " tokens and coins. `Coin` can be described as a secure wrapper around"
)]
#[cfg_attr(not(doctest), doc = " `Balance` type.")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod coin {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A coin of type `T` worth `value`. Transferable and storable"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct Coin<T> {
        pub id: super::object::UID,
        pub balance: super::balance::Balance<T>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Coin<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            balance: super::balance::Balance<T>,
        ) -> Self {
            Self {
                id,
                balance,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for Coin<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Each Coin type T created through `create_currency` function will have a"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " unique instance of CoinMetadata<T> that stores the metadata for this coin type."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct CoinMetadata<T> {
        pub id: super::object::UID,
        /// Number of decimal places the coin uses.
        /// A coin with `value ` N and `decimals` D should be shown as N / 10^D
        /// E.g., a coin with `value` 7002 and decimals 3 should be displayed as 7.002
        /// This is metadata for display usage only.
        pub decimals: u8,
        /// Name for the token
        pub name: ::moverox_sui::std::string::String,
        /// Symbol for the token
        pub symbol: ::moverox_sui::std::ascii::String,
        /// Description of the token
        pub description: ::moverox_sui::std::string::String,
        /// URL for the token logo
        pub icon_url: Option<super::url::Url>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> CoinMetadata<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            decimals: u8,
            name: ::moverox_sui::std::string::String,
            symbol: ::moverox_sui::std::ascii::String,
            description: ::moverox_sui::std::string::String,
            icon_url: Option<super::url::Url>,
        ) -> Self {
            Self {
                id,
                decimals,
                name,
                symbol,
                description,
                icon_url,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for CoinMetadata<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Similar to CoinMetadata, but created only for regulated coins that use the DenyList."
    )]
    #[cfg_attr(not(doctest), doc = " This object is always immutable.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct RegulatedCoinMetadata<T> {
        pub id: super::object::UID,
        /// The ID of the coin's CoinMetadata object.
        pub coin_metadata_object: super::object::ID,
        /// The ID of the coin's DenyCap object.
        pub deny_cap_object: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> RegulatedCoinMetadata<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            coin_metadata_object: super::object::ID,
            deny_cap_object: super::object::ID,
        ) -> Self {
            Self {
                id,
                coin_metadata_object,
                deny_cap_object,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for RegulatedCoinMetadata<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(not(doctest), doc = " Capability allowing the bearer to mint and burn")]
    #[cfg_attr(not(doctest), doc = " coins of type `T`. Transferable")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct TreasuryCap<T> {
        pub id: super::object::UID,
        pub total_supply: super::balance::Supply<T>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TreasuryCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            total_supply: super::balance::Supply<T>,
        ) -> Self {
            Self {
                id,
                total_supply,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for TreasuryCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Capability allowing the bearer to deny addresses from using the currency's coins--"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " immediately preventing those addresses from interacting with the coin as an input to a"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " transaction and at the start of the next preventing them from receiving the coin."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " If `allow_global_pause` is true, the bearer can enable a global pause that behaves as if"
    )]
    #[cfg_attr(not(doctest), doc = " all addresses were added to the deny list.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct DenyCapV2<T> {
        pub id: super::object::UID,
        pub allow_global_pause: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DenyCapV2<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, allow_global_pause: bool) -> Self {
            Self {
                id,
                allow_global_pause,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for DenyCapV2<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct CurrencyCreated<T> {
        pub decimals: u8,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> CurrencyCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(decimals: u8) -> Self {
            Self {
                decimals,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Capability allowing the bearer to freeze addresses, preventing those addresses from"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " interacting with the coin as an input to a transaction."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = coin)]
    #[allow(non_snake_case)]
    pub struct DenyCap<T> {
        pub id: super::object::UID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DenyCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for DenyCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod config {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct Config<WriteCap> {
        pub id: super::object::UID,
        #[serde(skip)]
        _WriteCap: ::std::marker::PhantomData<WriteCap>,
    }
    impl<WriteCap> Config<WriteCap> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID) -> Self {
            Self {
                id,
                _WriteCap: ::std::marker::PhantomData,
            }
        }
    }
    impl<WriteCap> ::moverox::traits::HasKey for Config<WriteCap> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct Setting<Value> {
        pub data: Option<SettingData<Value>>,
    }
    impl<Value> Setting<Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(data: Option<SettingData<Value>>) -> Self {
            Self { data }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = config)]
    #[allow(non_snake_case)]
    pub struct SettingData<Value> {
        pub newer_value_epoch: u64,
        pub newer_value: Option<Value>,
        pub older_value_opt: Option<Value>,
    }
    impl<Value> SettingData<Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            newer_value_epoch: u64,
            newer_value: Option<Value>,
            older_value_opt: Option<Value>,
        ) -> Self {
            Self {
                newer_value_epoch,
                newer_value,
                older_value_opt,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines the `DenyList` type. The `DenyList` shared object is used to restrict access to"
)]
#[cfg_attr(
    not(doctest),
    doc = " instances of certain core types from being used as inputs by specified addresses in the deny"
)]
#[cfg_attr(not(doctest), doc = " list.")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod deny_list {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A shared object that stores the addresses that are blocked for a given core type."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct DenyList {
        pub id: super::object::UID,
        /// The individual deny lists.
        pub lists: super::bag::Bag,
    }
    impl DenyList {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, lists: super::bag::Bag) -> Self {
            Self { id, lists }
        }
    }
    impl ::moverox::traits::HasKey for DenyList {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The capability used to write to the deny list config. Ensures that the Configs for the"
    )]
    #[cfg_attr(not(doctest), doc = " DenyList are modified only by this module.")]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct ConfigWriteCap(bool);
    impl ConfigWriteCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The dynamic object field key used to store the `Config` for a given type, essentially a"
    )]
    #[cfg_attr(not(doctest), doc = " `(per_type_index, per_type_key)` pair.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct ConfigKey {
        pub per_type_index: u64,
        pub per_type_key: vector<u8>,
    }
    impl ConfigKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(per_type_index: u64, per_type_key: vector<u8>) -> Self {
            Self {
                per_type_index,
                per_type_key,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The setting key used to store the deny list for a given address in the `Config`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct AddressKey(pub address);
    impl AddressKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: address) -> Self {
            Self(_0)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The setting key used to store the global pause setting in the `Config`."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct GlobalPauseKey(bool);
    impl GlobalPauseKey {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false)
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The event emitted when a new `Config` is created for a given type. This can be useful for"
    )]
    #[cfg_attr(not(doctest), doc = " tracking the `ID` of a type's `Config` object.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct PerTypeConfigCreated {
        pub key: ConfigKey,
        pub config_id: super::object::ID,
    }
    impl PerTypeConfigCreated {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(key: ConfigKey, config_id: super::object::ID) -> Self {
            Self { key, config_id }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Stores the addresses that are denied for a given core type."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = deny_list)]
    #[allow(non_snake_case)]
    pub struct PerTypeList {
        pub id: super::object::UID,
        /// Number of object types that have been banned for a given address.
        /// Used to quickly skip checks for most addresses.
        pub denied_count: super::table::Table<address, u64>,
        /// Set of addresses that are banned for a given type.
        /// For example with `sui::coin::Coin`: If addresses A and B are banned from using
        /// "0...0123::my_coin::MY_COIN", this will be "0...0123::my_coin::MY_COIN" -> {A, B}.
        pub denied_addresses: super::table::Table<
            vector<u8>,
            super::vec_set::VecSet<address>,
        >,
    }
    impl PerTypeList {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            denied_count: super::table::Table<address, u64>,
            denied_addresses: super::table::Table<
                vector<u8>,
                super::vec_set::VecSet<address>,
            >,
        ) -> Self {
            Self {
                id,
                denied_count,
                denied_addresses,
            }
        }
    }
    impl ::moverox::traits::HasKey for PerTypeList {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines a Display struct which defines the way an Object"
)]
#[cfg_attr(
    not(doctest),
    doc = " should be displayed. The intention is to keep data as independent"
)]
#[cfg_attr(
    not(doctest),
    doc = " from its display as possible, protecting the development process"
)]
#[cfg_attr(
    not(doctest),
    doc = " and keeping it separate from the ecosystem agreements."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " Each of the fields of the Display object should allow for pattern"
)]
#[cfg_attr(
    not(doctest),
    doc = " substitution and filling-in the pieces using the data from the object T."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " More entry functions might be added in the future depending on the use cases."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod display {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " The Display<T> object. Defines the way a T instance should be"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " displayed. Display object can only be created and modified with"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " a PublisherCap, making sure that the rules are set by the owner"
    )]
    #[cfg_attr(not(doctest), doc = " of the type.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Each of the display properties should support patterns outside"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " of the system, making it simpler to customize Display based"
    )]
    #[cfg_attr(not(doctest), doc = " on the property values of an Object.")]
    #[cfg_attr(not(doctest), doc = " ```")]
    #[cfg_attr(not(doctest), doc = " // Example of a display object")]
    #[cfg_attr(not(doctest), doc = " Display<0x...::capy::Capy> {")]
    #[cfg_attr(not(doctest), doc = "  fields:")]
    #[cfg_attr(not(doctest), doc = "    <name, \"Capy { genes }\">")]
    #[cfg_attr(not(doctest), doc = "    <link, \"https://capy.art/capy/{ id }\">")]
    #[cfg_attr(
        not(doctest),
        doc = "    <image, \"https://api.capy.art/capy/{ id }/svg\">"
    )]
    #[cfg_attr(not(doctest), doc = "    <description, \"Lovely Capy, one of many\">")]
    #[cfg_attr(not(doctest), doc = " }")]
    #[cfg_attr(not(doctest), doc = " ```")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Uses only String type due to external-facing nature of the object,"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the property names have a priority over their types."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct Display<T> {
        pub id: super::object::UID,
        /// Contains fields for display. Currently supported
        /// fields are: name, link, image and description.
        pub fields: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            ::moverox_sui::std::string::String,
        >,
        /// Version that can only be updated manually by the Publisher.
        pub version: u16,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Display<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            fields: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                ::moverox_sui::std::string::String,
            >,
            version: u16,
        ) -> Self {
            Self {
                id,
                fields,
                version,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for Display<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Event: emitted when a new Display object has been created for type T."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Type signature of the event corresponds to the type while id serves for"
    )]
    #[cfg_attr(not(doctest), doc = " the discovery.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " Since Sui RPC supports querying events by type, finding a Display for the T"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " would be as simple as looking for the first event with `Display<T>`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct DisplayCreated<T> {
        pub id: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> DisplayCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self {
                id,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(not(doctest), doc = " Version of Display got updated -")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = display)]
    #[allow(non_snake_case)]
    pub struct VersionUpdated<T> {
        pub id: super::object::ID,
        pub version: u16,
        pub fields: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            ::moverox_sui::std::string::String,
        >,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> VersionUpdated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::ID,
            version: u16,
            fields: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                ::moverox_sui::std::string::String,
            >,
        ) -> Self {
            Self {
                id,
                version,
                fields,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " In addition to the fields declared in its type definition, a Sui object can have dynamic fields"
)]
#[cfg_attr(
    not(doctest),
    doc = " that can be added after the object has been constructed. Unlike ordinary field names"
)]
#[cfg_attr(
    not(doctest),
    doc = " (which are always statically declared identifiers) a dynamic field name can be any value with"
)]
#[cfg_attr(
    not(doctest),
    doc = " the `copy`, `drop`, and `store` abilities, e.g. an integer, a boolean, or a string."
)]
#[cfg_attr(
    not(doctest),
    doc = " This gives Sui programmers the flexibility to extend objects on-the-fly, and it also serves as a"
)]
#[cfg_attr(not(doctest), doc = " building block for core collection types")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod dynamic_field {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Internal object used for storing the field and value"
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = dynamic_field)]
    #[allow(non_snake_case)]
    pub struct Field<Name, Value> {
        /// Determined by the hash of the object ID, the field name value and it's type,
        /// i.e. hash(parent.id || name || Name)
        pub id: super::object::UID,
        /// The value for the name of this field
        pub name: Name,
        /// The value bound to this field
        pub value: Value,
    }
    impl<Name, Value> Field<Name, Value> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, name: Name, value: Value) -> Self {
            Self { id, name, value }
        }
    }
    impl<Name, Value> ::moverox::traits::HasKey for Field<Name, Value> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::dynamic_field`, this module allows for the access of dynamic fields. But"
)]
#[cfg_attr(
    not(doctest),
    doc = " unlike, `sui::dynamic_field` the values bound to these dynamic fields _must_ be objects"
)]
#[cfg_attr(
    not(doctest),
    doc = " themselves. This allows for the objects to still exist within in storage, which may be important"
)]
#[cfg_attr(
    not(doctest),
    doc = " for external tools. The difference is otherwise not observable from within Move."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod dynamic_object_field {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = dynamic_object_field)]
    #[allow(non_snake_case)]
    pub struct Wrapper<Name> {
        pub name: Name,
    }
    impl<Name> Wrapper<Name> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(name: Name) -> Self {
            Self { name }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::table` but the values are linked together, allowing for ordered insertion and"
)]
#[cfg_attr(not(doctest), doc = " removal")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod linked_table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = linked_table)]
    #[allow(non_snake_case)]
    pub struct LinkedTable<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        /// the front of the table, i.e. the key of the first entry
        pub head: Option<K>,
        /// the back of the table, i.e. the key of the last entry
        pub tail: Option<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> LinkedTable<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            size: u64,
            head: Option<K>,
            tail: Option<K>,
        ) -> Self {
            Self {
                id,
                size,
                head,
                tail,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<K, V> ::moverox::traits::HasKey for LinkedTable<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = linked_table)]
    #[allow(non_snake_case)]
    pub struct Node<K, V> {
        /// the previous key
        pub prev: Option<K>,
        /// the next key
        pub next: Option<K>,
        /// the value being stored
        pub value: V,
    }
    impl<K, V> Node<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(prev: Option<K>, next: Option<K>, value: V) -> Self {
            Self { prev, next, value }
        }
    }
}
#[cfg_attr(not(doctest), doc = " Sui object identifiers")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod object {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " An object ID. This is used to reference Sui Objects."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This is *not* guaranteed to be globally unique--anyone can create an `ID` from a `UID` or"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " from an object, and ID's can be freely copied and dropped."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Here, the values are not globally unique because there can be multiple values of type `ID`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " with the same underlying bytes. For example, `object::id(&obj)` can be called as many times"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " as you want for a given `obj`, and each `ID` value will be identical."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object)]
    #[allow(non_snake_case)]
    pub struct ID {
        pub bytes: address,
    }
    impl ID {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: address) -> Self {
            Self { bytes }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Globally unique IDs that define an object's ID in storage. Any Sui Object, that is a struct"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " with the `key` ability, must have `id: UID` as its first field."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " These are globally unique in the sense that no two values of type `UID` are ever equal, in"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " other words for any two values `id1: UID` and `id2: UID`, `id1` != `id2`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This is a privileged type that can only be derived from a `TxContext`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `UID` doesn't have the `drop` ability, so deleting a `UID` requires a call to `delete`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object)]
    #[allow(non_snake_case)]
    pub struct UID {
        pub id: super::object::ID,
    }
    impl UID {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID) -> Self {
            Self { id }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::bag`, an `ObjectBag` is a heterogeneous map-like collection. But unlike"
)]
#[cfg_attr(
    not(doctest),
    doc = " `sui::bag`, the values bound to these dynamic fields _must_ be objects themselves. This allows"
)]
#[cfg_attr(
    not(doctest),
    doc = " for the objects to still exist in storage, which may be important for external tools."
)]
#[cfg_attr(
    not(doctest),
    doc = " The difference is otherwise not observable from within Move."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod object_bag {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object_bag)]
    #[allow(non_snake_case)]
    pub struct ObjectBag {
        /// the ID of this bag
        pub id: super::object::UID,
        /// the number of key-value pairs in the bag
        pub size: u64,
    }
    impl ObjectBag {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self { id, size }
        }
    }
    impl ::moverox::traits::HasKey for ObjectBag {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Similar to `sui::table`, an `ObjectTable<K, V>` is a map-like collection. But unlike"
)]
#[cfg_attr(
    not(doctest),
    doc = " `sui::table`, the values bound to these dynamic fields _must_ be objects themselves. This allows"
)]
#[cfg_attr(
    not(doctest),
    doc = " for the objects to still exist within in storage, which may be important for external tools."
)]
#[cfg_attr(
    not(doctest),
    doc = " The difference is otherwise not observable from within Move."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod object_table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = object_table)]
    #[allow(non_snake_case)]
    pub struct ObjectTable<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        #[serde(skip)]
        _K: ::std::marker::PhantomData<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> ObjectTable<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self {
                id,
                size,
                _K: ::std::marker::PhantomData,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<K, V> ::moverox::traits::HasKey for ObjectTable<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Functions for operating on Move packages from within Move:"
)]
#[cfg_attr(
    not(doctest),
    doc = " - Creating proof-of-publish objects from one-time witnesses"
)]
#[cfg_attr(
    not(doctest),
    doc = " - Administering package upgrades through upgrade policies."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod package {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " This type can only be created in the transaction that"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " generates a module, by consuming its one-time witness, so it"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " can be used to identify the address that published the package"
    )]
    #[cfg_attr(not(doctest), doc = " a type originated from.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct Publisher {
        pub id: super::object::UID,
        pub package: ::moverox_sui::std::ascii::String,
        pub module_name: ::moverox_sui::std::ascii::String,
    }
    impl Publisher {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            package: ::moverox_sui::std::ascii::String,
            module_name: ::moverox_sui::std::ascii::String,
        ) -> Self {
            Self { id, package, module_name }
        }
    }
    impl ::moverox::traits::HasKey for Publisher {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Capability controlling the ability to upgrade a package."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeCap {
        pub id: super::object::UID,
        /// (Mutable) ID of the package that can be upgraded.
        pub package: super::object::ID,
        /// (Mutable) The number of upgrades that have been applied
        /// successively to the original package.  Initially 0.
        pub version: u64,
        /// What kind of upgrades are allowed.
        pub policy: u8,
    }
    impl UpgradeCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            package: super::object::ID,
            version: u64,
            policy: u8,
        ) -> Self {
            Self {
                id,
                package,
                version,
                policy,
            }
        }
    }
    impl ::moverox::traits::HasKey for UpgradeCap {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Permission to perform a particular upgrade (for a fixed version of"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the package, bytecode to upgrade with and transitive dependencies to"
    )]
    #[cfg_attr(not(doctest), doc = " depend against).")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " An `UpgradeCap` can only issue one ticket at a time, to prevent races"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " between concurrent updates or a change in its upgrade policy after"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " issuing a ticket, so the ticket is a \"Hot Potato\" to preserve forward"
    )]
    #[cfg_attr(not(doctest), doc = " progress.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeTicket {
        /// (Immutable) ID of the `UpgradeCap` this originated from.
        pub cap: super::object::ID,
        /// (Immutable) ID of the package that can be upgraded.
        pub package: super::object::ID,
        /// (Immutable) The policy regarding what kind of upgrade this ticket
        /// permits.
        pub policy: u8,
        /// (Immutable) SHA256 digest of the bytecode and transitive
        /// dependencies that will be used in the upgrade.
        pub digest: vector<u8>,
    }
    impl UpgradeTicket {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            cap: super::object::ID,
            package: super::object::ID,
            policy: u8,
            digest: vector<u8>,
        ) -> Self {
            Self {
                cap,
                package,
                policy,
                digest,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Issued as a result of a successful upgrade, containing the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " information to be used to update the `UpgradeCap`.  This is a \"Hot"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Potato\" to ensure that it is used to update its `UpgradeCap` before"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the end of the transaction that performed the upgrade."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = package)]
    #[allow(non_snake_case)]
    pub struct UpgradeReceipt {
        /// (Immutable) ID of the `UpgradeCap` this originated from.
        pub cap: super::object::ID,
        /// (Immutable) ID of the package after it was upgraded.
        pub package: super::object::ID,
    }
    impl UpgradeReceipt {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(cap: super::object::ID, package: super::object::ID) -> Self {
            Self { cap, package }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod party {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " The permissions that apply to a party object. If the transaction sender has an entry in"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the `members` map, the permissions in that entry apply. Otherwise, the `default` permissions"
    )]
    #[cfg_attr(not(doctest), doc = " are used.")]
    #[cfg_attr(
        not(doctest),
        doc = " If the party has the `READ` permission, the object can be taken as an immutable input."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " If the party has the `WRITE`, `DELETE`, or `TRANSFER` permissions, the object can be taken as"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " a mutable input. Additional restrictions pertaining to each permission are checked at the end"
    )]
    #[cfg_attr(not(doctest), doc = " of transaction execution.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = party)]
    #[allow(non_snake_case)]
    pub struct Party {
        /// The permissions that apply if no specific permissions are set in the `members` map.
        pub default: Permissions,
        /// The permissions per transaction sender.
        pub members: super::vec_map::VecMap<address, Permissions>,
    }
    impl Party {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            default: Permissions,
            members: super::vec_map::VecMap<address, Permissions>,
        ) -> Self {
            Self { default, members }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " The permissions that a party has. The permissions are a bitset of the `READ`, `WRITE`,"
    )]
    #[cfg_attr(not(doctest), doc = " `DELETE`, and `TRANSFER` constants.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = party)]
    #[allow(non_snake_case)]
    pub struct Permissions(pub u64);
    impl Permissions {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: u64) -> Self {
            Self(_0)
        }
    }
}
#[cfg_attr(not(doctest), doc = " Priority queue implemented using a max heap.")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod priority_queue {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Struct representing a priority queue. The `entries` vector represents a max"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " heap structure, where entries[0] is the root, entries[1] and entries[2] are the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " left child and right child of the root, etc. More generally, the children of"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " entries[i] are at i * 2 + 1 and i * 2 + 2. The max heap should have the invariant"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " that the parent node's priority is always higher than its child nodes' priorities."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = priority_queue)]
    #[allow(non_snake_case)]
    pub struct PriorityQueue<T> {
        pub entries: vector<Entry<T>>,
    }
    impl<T> PriorityQueue<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(entries: vector<Entry<T>>) -> Self {
            Self { entries }
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = priority_queue)]
    #[allow(non_snake_case)]
    pub struct Entry<T> {
        pub priority: u64,
        pub value: T,
    }
    impl<T> Entry<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(priority: u64, value: T) -> Self {
            Self { priority, value }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " This module provides functionality for generating secure randomness."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod random {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Singleton shared object which stores the global randomness state."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The actual state is stored in a versioned inner field."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct Random {
        pub id: super::object::UID,
        pub inner: super::versioned::Versioned,
    }
    impl Random {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            inner: super::versioned::Versioned,
        ) -> Self {
            Self { id, inner }
        }
    }
    impl ::moverox::traits::HasKey for Random {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct RandomInner {
        pub version: u64,
        pub epoch: u64,
        pub randomness_round: u64,
        pub random_bytes: vector<u8>,
    }
    impl RandomInner {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            version: u64,
            epoch: u64,
            randomness_round: u64,
            random_bytes: vector<u8>,
        ) -> Self {
            Self {
                version,
                epoch,
                randomness_round,
                random_bytes,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Unique randomness generator, derived from the global randomness."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = random)]
    #[allow(non_snake_case)]
    pub struct RandomGenerator {
        pub seed: vector<u8>,
        pub counter: u16,
        pub buffer: vector<u8>,
    }
    impl RandomGenerator {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(seed: vector<u8>, counter: u16, buffer: vector<u8>) -> Self {
            Self { seed, counter, buffer }
        }
    }
}
#[cfg_attr(not(doctest), doc = " Coin<SUI> is the token used to pay for gas in Sui.")]
#[cfg_attr(
    not(doctest),
    doc = " It has 9 decimals, and the smallest unit (10^-9) is called \"mist\"."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod sui {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " Name of the coin")]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = sui)]
    #[allow(non_snake_case)]
    pub struct SUI {
        /// BCS for empty structs actually encodes a single boolean hidden field
        dummy_field: bool,
    }
    impl SUI {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self { dummy_field: false }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A table is a map-like collection. But unlike a traditional collection, it's keys and values are"
)]
#[cfg_attr(
    not(doctest),
    doc = " not stored within the `Table` value, but instead are stored using Sui's object system. The"
)]
#[cfg_attr(
    not(doctest),
    doc = " `Table` struct acts only as a handle into the object system to retrieve those keys and values."
)]
#[cfg_attr(
    not(doctest),
    doc = " Note that this means that `Table` values with exactly the same key-value mapping will not be"
)]
#[cfg_attr(not(doctest), doc = " equal, with `==`, at runtime. For example")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = " let table1 = table::new<u64, bool>();")]
#[cfg_attr(not(doctest), doc = " let table2 = table::new<u64, bool>();")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table1, 0, false);")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table1, 1, true);")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table2, 0, false);")]
#[cfg_attr(not(doctest), doc = " table::add(&mut table2, 1, true);")]
#[cfg_attr(
    not(doctest),
    doc = " // table1 does not equal table2, despite having the same entries"
)]
#[cfg_attr(not(doctest), doc = " assert!(&table1 != &table2);")]
#[cfg_attr(not(doctest), doc = " ```")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod table {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = table)]
    #[allow(non_snake_case)]
    pub struct Table<K, V> {
        /// the ID of this table
        pub id: super::object::UID,
        /// the number of key-value pairs in the table
        pub size: u64,
        #[serde(skip)]
        _K: ::std::marker::PhantomData<K>,
        #[serde(skip)]
        _V: ::std::marker::PhantomData<V>,
    }
    impl<K, V> Table<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, size: u64) -> Self {
            Self {
                id,
                size,
                _K: ::std::marker::PhantomData,
                _V: ::std::marker::PhantomData,
            }
        }
    }
    impl<K, V> ::moverox::traits::HasKey for Table<K, V> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " A basic scalable vector library implemented using `Table`."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod table_vec {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = table_vec)]
    #[allow(non_snake_case)]
    pub struct TableVec<Element> {
        /// The contents of the table vector.
        pub contents: super::table::Table<u64, Element>,
        #[serde(skip)]
        _Element: ::std::marker::PhantomData<Element>,
    }
    impl<Element> TableVec<Element> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: super::table::Table<u64, Element>) -> Self {
            Self {
                contents,
                _Element: ::std::marker::PhantomData,
            }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " The Token module which implements a Closed Loop Token with a configurable"
)]
#[cfg_attr(
    not(doctest),
    doc = " policy. The policy is defined by a set of rules that must be satisfied for"
)]
#[cfg_attr(not(doctest), doc = " an action to be performed on the token.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " The module is designed to be used with a `TreasuryCap` to allow for minting"
)]
#[cfg_attr(
    not(doctest),
    doc = " and burning of the `Token`s. And can act as a replacement / extension or a"
)]
#[cfg_attr(not(doctest), doc = " companion to existing open-loop (`Coin`) systems.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(
    not(doctest),
    doc = " Module:      sui::balance       sui::coin             sui::token"
)]
#[cfg_attr(
    not(doctest),
    doc = " Main type:   Balance<T>         Coin<T>               Token<T>"
)]
#[cfg_attr(
    not(doctest),
    doc = " Capability:  Supply<T>  <---->  TreasuryCap<T> <----> TreasuryCap<T>"
)]
#[cfg_attr(
    not(doctest),
    doc = " Abilities:   store              key + store           key"
)]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " The Token system allows for fine-grained control over the actions performed"
)]
#[cfg_attr(
    not(doctest),
    doc = " on the token. And hence it is highly suitable for applications that require"
)]
#[cfg_attr(
    not(doctest),
    doc = " control over the currency which a simple open-loop system can't provide."
)]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod token {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A single `Token` with `Balance` inside. Can only be owned by an address,"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " and actions performed on it must be confirmed in a matching `TokenPolicy`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct Token<T> {
        pub id: super::object::UID,
        /// The Balance of the `Token`.
        pub balance: super::balance::Balance<T>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Token<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            balance: super::balance::Balance<T>,
        ) -> Self {
            Self {
                id,
                balance,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for Token<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A Capability that manages a single `TokenPolicy` specified in the `for`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " field. Created together with `TokenPolicy` in the `new` function."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicyCap<T> {
        pub id: super::object::UID,
        pub r#for: super::object::ID,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicyCap<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, r#for: super::object::ID) -> Self {
            Self {
                id,
                r#for,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for TokenPolicyCap<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " `TokenPolicy` represents a set of rules that define what actions can be"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " performed on a `Token` and which `Rules` must be satisfied for the"
    )]
    #[cfg_attr(not(doctest), doc = " action to succeed.")]
    #[cfg_attr(not(doctest), doc = "")]
    #[cfg_attr(
        not(doctest),
        doc = " - For the sake of availability, `TokenPolicy` is a `key`-only object."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " - Each `TokenPolicy` is managed by a matching `TokenPolicyCap`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " - For an action to become available, there needs to be a record in the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `rules` VecMap. To allow an action to be performed freely, there's an"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `allow` function that can be called by the `TokenPolicyCap` owner."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicy<T> {
        pub id: super::object::UID,
        /// The balance that is effectively spent by the user on the "spend"
        /// action. However, actual decrease of the supply can only be done by
        /// the `TreasuryCap` owner when `flush` is called.
        ///
        /// This balance is effectively spent and cannot be accessed by anyone
        /// but the `TreasuryCap` owner.
        pub spent_balance: super::balance::Balance<T>,
        /// The set of rules that define what actions can be performed on the
        /// token. For each "action" there's a set of Rules that must be
        /// satisfied for the `ActionRequest` to be confirmed.
        pub rules: super::vec_map::VecMap<
            ::moverox_sui::std::string::String,
            super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        >,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicy<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            id: super::object::UID,
            spent_balance: super::balance::Balance<T>,
            rules: super::vec_map::VecMap<
                ::moverox_sui::std::string::String,
                super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
            >,
        ) -> Self {
            Self {
                id,
                spent_balance,
                rules,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    impl<T> ::moverox::traits::HasKey for TokenPolicy<T> {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " A request to perform an \"Action\" on a token. Stores the information"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " about the action to be performed and must be consumed by the `confirm_request`"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " or `confirm_request_mut` functions when the Rules are satisfied."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct ActionRequest<T> {
        /// Name of the Action to look up in the Policy. Name can be one of the
        /// default actions: `transfer`, `spend`, `to_coin`, `from_coin` or a
        /// custom action.
        pub name: ::moverox_sui::std::string::String,
        /// Amount is present in all of the txs
        pub amount: u64,
        /// Sender is a permanent field always
        pub sender: address,
        /// Recipient is only available in `transfer` action.
        pub recipient: Option<address>,
        /// The balance to be "spent" in the `TokenPolicy`, only available
        /// in the `spend` action.
        pub spent_balance: Option<super::balance::Balance<T>>,
        /// Collected approvals (stamps) from completed `Rules`. They're matched
        /// against `TokenPolicy.rules` to determine if the request can be
        /// confirmed.
        pub approvals: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> ActionRequest<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            name: ::moverox_sui::std::string::String,
            amount: u64,
            sender: address,
            recipient: Option<address>,
            spent_balance: Option<super::balance::Balance<T>>,
            approvals: super::vec_set::VecSet<::moverox_sui::std::type_name::TypeName>,
        ) -> Self {
            Self {
                name,
                amount,
                sender,
                recipient,
                spent_balance,
                approvals,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Dynamic field key for the `TokenPolicy` to store the `Config` for a"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " specific action `Rule`. There can be only one configuration per"
    )]
    #[cfg_attr(not(doctest), doc = " `Rule` per `TokenPolicy`.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct RuleKey<T> {
        pub is_protected: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> RuleKey<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(is_protected: bool) -> Self {
            Self {
                is_protected,
                _T: ::std::marker::PhantomData,
            }
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " An event emitted when a `TokenPolicy` is created and shared. Because"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `TokenPolicy` can only be shared (and potentially frozen in the future),"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " we emit this event in the `share_policy` function and mark it as mutable."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = token)]
    #[allow(non_snake_case)]
    pub struct TokenPolicyCreated<T> {
        /// ID of the `TokenPolicy` that was created.
        pub id: super::object::ID,
        /// Whether the `TokenPolicy` is "shared" (mutable) or "frozen"
        /// (immutable) - TBD.
        pub is_mutable: bool,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> TokenPolicyCreated<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID, is_mutable: bool) -> Self {
            Self {
                id,
                is_mutable,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod transfer {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " This represents the ability to `receive` an object of type `T`."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This type is ephemeral per-transaction and cannot be stored on-chain."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This does not represent the obligation to receive the object that it"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " references, but simply the ability to receive the object with object ID"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " `id` at version `version` if you can prove mutable access to the parent"
    )]
    #[cfg_attr(not(doctest), doc = " object during the transaction.")]
    #[cfg_attr(
        not(doctest),
        doc = " Internals of this struct are opaque outside this module."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = transfer)]
    #[allow(non_snake_case)]
    pub struct Receiving<T> {
        pub id: super::object::ID,
        pub version: u64,
        #[serde(skip)]
        _T: ::std::marker::PhantomData<T>,
    }
    impl<T> Receiving<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::ID, version: u64) -> Self {
            Self {
                id,
                version,
                _T: ::std::marker::PhantomData,
            }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod tx_context {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Information about the transaction currently being executed."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This cannot be constructed by a transaction--it is a privileged object created by"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " the VM and passed in to the entrypoint of the transaction as `&mut TxContext`."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = tx_context)]
    #[allow(non_snake_case)]
    pub struct TxContext {
        /// The address of the user that signed the current transaction
        pub sender: address,
        /// Hash of the current transaction
        pub tx_hash: vector<u8>,
        /// The current epoch number
        pub epoch: u64,
        /// Timestamp that the epoch started at
        pub epoch_timestamp_ms: u64,
        /// Counter recording the number of fresh id's created while executing
        /// this transaction. Always 0 at the start of a transaction
        pub ids_created: u64,
    }
    impl TxContext {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(
            sender: address,
            tx_hash: vector<u8>,
            epoch: u64,
            epoch_timestamp_ms: u64,
            ids_created: u64,
        ) -> Self {
            Self {
                sender,
                tx_hash,
                epoch,
                epoch_timestamp_ms,
                ids_created,
            }
        }
    }
}
#[cfg_attr(not(doctest), doc = " URL: standard Uniform Resource Locator string")]
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod url {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " Standard Uniform Resource Locator (URL) string.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = url)]
    #[allow(non_snake_case)]
    pub struct Url {
        pub url: ::moverox_sui::std::ascii::String,
    }
    impl Url {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(url: ::moverox_sui::std::ascii::String) -> Self {
            Self { url }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod vec_map {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A map data structure backed by a vector. The map is guaranteed not to contain duplicate keys, but entries"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " are *not* sorted by key--entries are included in insertion order."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " All operations are O(N) in the size of the map--the intention of this data structure is only to provide"
    )]
    #[cfg_attr(not(doctest), doc = " the convenience of programming against a map API.")]
    #[cfg_attr(
        not(doctest),
        doc = " Large maps should use handwritten parent/child relationships instead."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " Maps that need sorted iteration rather than insertion order iteration should also be handwritten."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_map)]
    #[allow(non_snake_case)]
    pub struct VecMap<K, V> {
        pub contents: vector<Entry<K, V>>,
    }
    impl<K, V> VecMap<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: vector<Entry<K, V>>) -> Self {
            Self { contents }
        }
    }
    #[cfg_attr(not(doctest), doc = " An entry in the map")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_map)]
    #[allow(non_snake_case)]
    pub struct Entry<K, V> {
        pub key: K,
        pub value: V,
    }
    impl<K, V> Entry<K, V> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(key: K, value: V) -> Self {
            Self { key, value }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod vec_set {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A set data structure backed by a vector. The set is guaranteed not to"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " contain duplicate keys. All operations are O(N) in the size of the set"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " - the intention of this data structure is only to provide the convenience"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " of programming against a set API. Sets that need sorted iteration rather"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " than insertion order iteration should be handwritten."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = vec_set)]
    #[allow(non_snake_case)]
    pub struct VecSet<K> {
        pub contents: vector<K>,
    }
    impl<K> VecSet<K> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(contents: vector<K>) -> Self {
            Self { contents }
        }
    }
}
#[allow(rustdoc::all)]
#[cfg(not(doctest))]
pub mod versioned {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A wrapper type that supports versioning of the inner type."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " The inner type is a dynamic field of the Versioned object, and is keyed using version."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " User of this type could load the inner object using corresponding type based on the version."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " You can also upgrade the inner object to a new type version."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " If you want to support lazy upgrade of the inner type, one caveat is that all APIs would have"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " to use mutable reference even if it's a read-only API."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = versioned)]
    #[allow(non_snake_case)]
    pub struct Versioned {
        pub id: super::object::UID,
        pub version: u64,
    }
    impl Versioned {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(id: super::object::UID, version: u64) -> Self {
            Self { id, version }
        }
    }
    impl ::moverox::traits::HasKey for Versioned {
        fn address(&self) -> ::moverox::types::Address {
            self.id.id.bytes
        }
    }
    #[cfg_attr(
        not(doctest),
        doc = " Represents a hot potato object generated when we take out the dynamic field."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This is to make sure that we always put a new value back."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x2")]
    #[move_(module = versioned)]
    #[allow(non_snake_case)]
    pub struct VersionChangeCap {
        pub versioned_id: super::object::ID,
        pub old_version: u64,
    }
    impl VersionChangeCap {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(versioned_id: super::object::ID, old_version: u64) -> Self {
            Self { versioned_id, old_version }
        }
    }
}
