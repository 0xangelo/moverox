---
source: crates/moverox-build/src/tests.rs
expression: move_stdlib
---
#[cfg_attr(
    not(doctest),
    doc = " The `ASCII` module defines basic string and char newtypes in Move that verify"
)]
#[cfg_attr(
    not(doctest),
    doc = " that characters are valid ASCII, and that strings consist of only valid ASCII characters."
)]
#[allow(rustdoc::all)]
pub mod ascii {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " The `String` struct holds a vector of bytes that all represent"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " valid ASCII characters. Note that these ASCII characters may not all"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " be printable. To determine if a `String` contains only \"printable\""
    )]
    #[cfg_attr(
        not(doctest),
        doc = " characters you should use the `all_characters_printable` predicate"
    )]
    #[cfg_attr(not(doctest), doc = " defined in this module.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = ascii)]
    #[allow(non_snake_case)]
    pub struct String {
        pub bytes: vector<u8>,
    }
    impl String {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self { bytes }
        }
    }
    #[cfg_attr(not(doctest), doc = " An ASCII character.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = ascii)]
    #[allow(non_snake_case)]
    pub struct Char {
        pub byte: u8,
    }
    impl Char {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(byte: u8) -> Self {
            Self { byte }
        }
    }
}
#[allow(rustdoc::all)]
pub mod bit_vector {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = bit_vector)]
    #[allow(non_snake_case)]
    pub struct BitVector {
        pub length: u64,
        pub bit_field: vector<bool>,
    }
    impl BitVector {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(length: u64, bit_field: vector<bool>) -> Self {
            Self { length, bit_field }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines a fixed-point numeric type with a 32-bit integer part and"
)]
#[cfg_attr(not(doctest), doc = " a 32-bit fractional part.")]
#[allow(rustdoc::all)]
pub mod fixed_point32 {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Define a fixed-point numeric type with 32 fractional bits."
    )]
    #[cfg_attr(
        not(doctest),
        doc = " This is just a u64 integer but it is wrapped in a struct to"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " make a unique type. This is a binary representation, so decimal"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " values may not be exactly representable, but it provides more"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " than 9 decimal digits of precision both before and after the"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " decimal point (18 digits total). For comparison, double precision"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " floating-point has less than 16 decimal digits of precision, so"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " be careful about using floating-point to convert these values to"
    )]
    #[cfg_attr(not(doctest), doc = " decimal.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = fixed_point32)]
    #[allow(non_snake_case)]
    pub struct FixedPoint32 {
        pub value: u64,
    }
    impl FixedPoint32 {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(value: u64) -> Self {
            Self { value }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines the `Permit` type, which can be used to constrain the logic of a"
)]
#[cfg_attr(
    not(doctest),
    doc = " generic function to be authorized only by the module that defines the type"
)]
#[cfg_attr(not(doctest), doc = " parameter.")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ```move")]
#[cfg_attr(not(doctest), doc = " module example::use_permit;")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " public struct MyType { /* ... */ }")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " public fun test_permit() {")]
#[cfg_attr(not(doctest), doc = "    let permit = internal::permit<MyType>();")]
#[cfg_attr(not(doctest), doc = "    /* external_module::call_with_permit(permit); */")]
#[cfg_attr(not(doctest), doc = " }")]
#[cfg_attr(not(doctest), doc = " ```")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " To write a function that is guarded by a `Permit`, require it as an argument."
)]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(not(doctest), doc = " ```move")]
#[cfg_attr(
    not(doctest),
    doc = " // Silly mockup of a type registry where a type can be registered only by"
)]
#[cfg_attr(not(doctest), doc = " // the module that defines the type.")]
#[cfg_attr(not(doctest), doc = " module example::type_registry;")]
#[cfg_attr(not(doctest), doc = "")]
#[cfg_attr(
    not(doctest),
    doc = " public fun register_type<T>(_: internal::Permit<T> /* ... */) {"
)]
#[cfg_attr(not(doctest), doc = "   /* ... */")]
#[cfg_attr(not(doctest), doc = " }")]
#[cfg_attr(not(doctest), doc = " ```")]
#[allow(rustdoc::all)]
pub mod internal {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(not(doctest), doc = " A privileged witness of the `T` type.")]
    #[cfg_attr(
        not(doctest),
        doc = " Instances can only be created by the module that defines the type `T`."
    )]
    #[derive(
        Default,
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = internal)]
    #[allow(non_snake_case)]
    pub struct Permit<T>(bool, #[serde(skip)] ::std::marker::PhantomData<T>);
    impl<T> Permit<T> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new() -> Self {
            Self(false, ::std::marker::PhantomData)
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " This module defines the Option type and its methods to represent and handle an optional value."
)]
#[allow(rustdoc::all)]
pub mod option {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " Abstraction of a value that may or may not be present. Implemented with a vector of size"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " zero or one because Move bytecode does not have ADTs."
    )]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = option)]
    #[allow(non_snake_case)]
    pub struct Option<Element> {
        pub vec: vector<Element>,
    }
    impl<Element> Option<Element> {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(vec: vector<Element>) -> Self {
            Self { vec }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " The `string` module defines the `String` type which represents UTF8 encoded"
)]
#[cfg_attr(not(doctest), doc = " strings.")]
#[allow(rustdoc::all)]
pub mod string {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A `String` holds a sequence of bytes which is guaranteed to be in utf8"
    )]
    #[cfg_attr(not(doctest), doc = " format.")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = string)]
    #[allow(non_snake_case)]
    pub struct String {
        pub bytes: vector<u8>,
    }
    impl String {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(bytes: vector<u8>) -> Self {
            Self { bytes }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Functionality for converting Move types into values. Use with care!"
)]
#[allow(rustdoc::all)]
pub mod type_name {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = type_name)]
    #[allow(non_snake_case)]
    pub struct TypeName {
        /// String representation of the type. All types are represented
        /// using their source syntax:
        /// "u8", "u64", "bool", "address", "vector", and so on for primitive types.
        /// Struct types are represented as fully qualified type names; e.g.
        /// `00000000000000000000000000000001::string::String` or
        /// `0000000000000000000000000000000a::module_name1::type_name1<0000000000000000000000000000000a::module_name2::type_name2<u64>>`
        /// Addresses are hex-encoded lowercase values of length ADDRESS_LENGTH (16, 20, or 32 depending on the Move platform)
        pub name: super::ascii::String,
    }
    impl TypeName {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(name: super::ascii::String) -> Self {
            Self { name }
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines an unsigned, fixed-point numeric type with a 32-bit integer part and a 32-bit fractional"
)]
#[cfg_attr(
    not(doctest),
    doc = " part. The notation `uq32_32` and `UQ32_32` is based on"
)]
#[cfg_attr(
    not(doctest),
    doc = " [Q notation](https://en.wikipedia.org/wiki/Q_(number_format)). `q` indicates it a fixed-point"
)]
#[cfg_attr(
    not(doctest),
    doc = " number. The `u` prefix indicates it is unsigned. The `32_32` suffix indicates the number of"
)]
#[cfg_attr(
    not(doctest),
    doc = " bits, where the first number indicates the number of bits in the integer part, and the second"
)]
#[cfg_attr(
    not(doctest),
    doc = " the number of bits in the fractional part--in this case 32 bits for each."
)]
#[allow(rustdoc::all)]
pub mod uq32_32 {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A fixed-point numeric type with 32 integer bits and 32 fractional bits, represented by an"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " underlying 64 bit value. This is a binary representation, so decimal values may not be exactly"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " representable, but it provides more than 9 decimal digits of precision both before and after the"
    )]
    #[cfg_attr(not(doctest), doc = " decimal point (18 digits total).")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = uq32_32)]
    #[allow(non_snake_case)]
    pub struct UQ32_32(pub u64);
    impl UQ32_32 {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: u64) -> Self {
            Self(_0)
        }
    }
}
#[cfg_attr(
    not(doctest),
    doc = " Defines an unsigned, fixed-point numeric type with a 64-bit integer part and a 64-bit fractional"
)]
#[cfg_attr(
    not(doctest),
    doc = " part. The notation `uq64_64` and `UQ64_64` is based on"
)]
#[cfg_attr(
    not(doctest),
    doc = " [Q notation](https://en.wikipedia.org/wiki/Q_(number_format)). `q` indicates it a fixed-point"
)]
#[cfg_attr(
    not(doctest),
    doc = " number. The `u` prefix indicates it is unsigned. The `64_64` suffix indicates the number of"
)]
#[cfg_attr(
    not(doctest),
    doc = " bits, where the first number indicates the number of bits in the integer part, and the second"
)]
#[cfg_attr(
    not(doctest),
    doc = " the number of bits in the fractional part--in this case 64 bits for each."
)]
#[allow(rustdoc::all)]
pub mod uq64_64 {
    #[allow(non_camel_case_types, unused)]
    type address = ::moverox::types::Address;
    #[allow(non_camel_case_types, unused)]
    type u256 = ::moverox::types::U256;
    #[allow(non_camel_case_types, unused)]
    type vector<T> = ::std::vec::Vec<T>;
    #[cfg_attr(
        not(doctest),
        doc = " A fixed-point numeric type with 64 integer bits and 64 fractional bits, represented by an"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " underlying 128 bit value. This is a binary representation, so decimal values may not be exactly"
    )]
    #[cfg_attr(
        not(doctest),
        doc = " representable, but it provides more than 19 decimal digits of precision both before and after"
    )]
    #[cfg_attr(not(doctest), doc = " the decimal point (38 digits total).")]
    #[derive(
        Clone,
        Debug,
        PartialEq,
        Eq,
        Hash,
        ::moverox::traits::MoveDatatype,
        ::moverox::serde::Deserialize,
        ::moverox::serde::Serialize,
    )]
    #[move_(crate = ::moverox::traits)]
    #[serde(crate = "::moverox::serde")]
    #[move_(address = "0x1")]
    #[move_(module = uq64_64)]
    #[allow(non_snake_case)]
    pub struct UQ64_64(pub u128);
    impl UQ64_64 {
        #[allow(clippy::just_underscores_and_digits, clippy::too_many_arguments)]
        pub const fn new(_0: u128) -> Self {
            Self(_0)
        }
    }
}
