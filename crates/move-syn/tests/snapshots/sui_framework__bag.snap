---
source: crates/move-syn/tests/sui-framework.rs
expression: ast.tokens_to_string()
---
# [doc = " A bag is a heterogeneous map-like collection. The collection is similar to `sui::table` in that"] # [doc = " its keys and values are not stored within the `Bag` value, but instead are stored using Sui's"] # [doc = " object system. The `Bag` struct acts only as a handle into the object system to retrieve those"] # [doc = " keys and values."] # [doc = " Note that this means that `Bag` values with exactly the same key-value mapping will not be"] # [doc = " equal, with `==`, at runtime. For example"] # [doc = " ```"] # [doc = " let bag1 = bag::new();"] # [doc = " let bag2 = bag::new();"] # [doc = " bag::add(&mut bag1, 0, false);"] # [doc = " bag::add(&mut bag1, 1, true);"] # [doc = " bag::add(&mut bag2, 0, false);"] # [doc = " bag::add(&mut bag2, 1, true);"] # [doc = " // bag1 does not equal bag2, despite having the same entries"] # [doc = " assert!(&bag1 != &bag2);"] # [doc = " ```"] # [doc = " At it's core, `sui::bag` is a wrapper around `UID` that allows for access to"] # [doc = " `sui::dynamic_field` while preventing accidentally stranding field values. A `UID` can be"] # [doc = " deleted, even if it has dynamic fields associated with it, but a bag, on the other hand, must be"] # [doc = " empty to be destroyed."] module sui :: bag ; use sui :: dynamic_field as field ; const EBagNotEmpty : u64 = 0 ; public struct Bag has key , store { # [doc = " the ID of this bag"] id : UID , # [doc = " the number of key-value pairs in the bag"] size : u64 , } # [doc = " Creates a new, empty bag"] public fun new (ctx : & mut TxContext) : Bag { Bag { id : object :: new (ctx) , size : 0 , } } # [doc = " Adds a key-value pair to the bag `bag: &mut Bag`"] # [doc = " Aborts with `sui::dynamic_field::EFieldAlreadyExists` if the bag already has an entry with"] # [doc = " that key `k: K`."] public fun add < K : copy + drop + store , V : store > (bag : & mut Bag , k : K , v : V) { field :: add (& mut bag . id , k , v) ; bag . size = bag . size + 1 ; } # [syntax (index)] # [doc = " Immutable borrows the value associated with the key in the bag `bag: &Bag`."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the bag does not have an entry with"] # [doc = " that key `k: K`."] # [doc = " Aborts with `sui::dynamic_field::EFieldTypeMismatch` if the bag has an entry for the key, but"] # [doc = " the value does not have the specified type."] public fun borrow < K : copy + drop + store , V : store > (bag : & Bag , k : K) : & V { field :: borrow (& bag . id , k) } # [syntax (index)] # [doc = " Mutably borrows the value associated with the key in the bag `bag: &mut Bag`."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the bag does not have an entry with"] # [doc = " that key `k: K`."] # [doc = " Aborts with `sui::dynamic_field::EFieldTypeMismatch` if the bag has an entry for the key, but"] # [doc = " the value does not have the specified type."] public fun borrow_mut < K : copy + drop + store , V : store > (bag : & mut Bag , k : K) : & mut V { field :: borrow_mut (& mut bag . id , k) } # [doc = " Mutably borrows the key-value pair in the bag `bag: &mut Bag` and returns the value."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the bag does not have an entry with"] # [doc = " that key `k: K`."] # [doc = " Aborts with `sui::dynamic_field::EFieldTypeMismatch` if the bag has an entry for the key, but"] # [doc = " the value does not have the specified type."] public fun remove < K : copy + drop + store , V : store > (bag : & mut Bag , k : K) : V { let v = field :: remove (& mut bag . id , k) ; bag . size = bag . size - 1 ; v } # [doc = " Returns true iff there is an value associated with the key `k: K` in the bag `bag: &Bag`"] public fun contains < K : copy + drop + store > (bag : & Bag , k : K) : bool { field :: exists_ < K > (& bag . id , k) } # [doc = " Returns true iff there is an value associated with the key `k: K` in the bag `bag: &Bag`"] # [doc = " with an assigned value of type `V`"] public fun contains_with_type < K : copy + drop + store , V : store > (bag : & Bag , k : K) : bool { field :: exists_with_type < K , V > (& bag . id , k) } # [doc = " Returns the size of the bag, the number of key-value pairs"] public fun length (bag : & Bag) : u64 { bag . size } # [doc = " Returns true iff the bag is empty (if `length` returns `0`)"] public fun is_empty (bag : & Bag) : bool { bag . size == 0 } # [doc = " Destroys an empty bag"] # [doc = " Aborts with `EBagNotEmpty` if the bag still contains values"] public fun destroy_empty (bag : Bag) { let Bag { id , size } = bag ; assert ! (size == 0 , EBagNotEmpty) ; id . delete () }
