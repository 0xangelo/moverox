---
source: crates/move-syn/tests/functions.rs
expression: signatures
---
fun new<K: copy + drop + store, V: store>(ctx: &mut sui::tx_context::TxContext): LinkedTable<K, V>
fun front<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>): &Option<K>
fun back<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>): &Option<K>
fun push_front<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>, k: K, value: V)
fun push_back<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>, k: K, value: V)
fun borrow<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>, k: K): &V
fun borrow_mut<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>, k: K): &mut V
fun prev<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>, k: K): &Option<K>
fun next<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>, k: K): &Option<K>
fun remove<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>, k: K): V
fun pop_front<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>): (K, V)
fun pop_back<K: copy + drop + store, V: store>(table: &mut LinkedTable<K, V>): (K, V)
fun contains<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>, k: K): bool
fun length<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>): u64
fun is_empty<K: copy + drop + store, V: store>(table: &LinkedTable<K, V>): bool
fun destroy_empty<K: copy + drop + store, V: store>(table: LinkedTable<K, V>)
fun drop<K: copy + drop + store, V: drop + store>(table: LinkedTable<K, V>)
