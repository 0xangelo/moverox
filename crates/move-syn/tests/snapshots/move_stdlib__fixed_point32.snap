---
source: crates/move-syn/tests/move-stdlib.rs
expression: ast.tokens_to_string()
---
# [doc = " Defines a fixed-point numeric type with a 32-bit integer part and"] # [doc = " a 32-bit fractional part."] # [deprecated (note = b"Use `std::uq32_32` instead. If you need to convert from a `FixedPoint32` to a `UQ32_32`, you can use the `std::fixed_point32::get_raw_value` with `std::uq32_32::from_raw_value`." ,) ,] module std :: fixed_point32 ; # [doc = " Define a fixed-point numeric type with 32 fractional bits."] # [doc = " This is just a u64 integer but it is wrapped in a struct to"] # [doc = " make a unique type. This is a binary representation, so decimal"] # [doc = " values may not be exactly representable, but it provides more"] # [doc = " than 9 decimal digits of precision both before and after the"] # [doc = " decimal point (18 digits total). For comparison, double precision"] # [doc = " floating-point has less than 16 decimal digits of precision, so"] # [doc = " be careful about using floating-point to convert these values to"] # [doc = " decimal."] public struct FixedPoint32 has copy , drop , store { value : u64 } # [doc = "> TODO: This is a basic constant and should be provided somewhere centrally in the framework."] const MAX_U64 : u128 = 18446744073709551615 ; # [doc = " The denominator provided was zero"] const EDENOMINATOR : u64 = 0x10001 ; # [doc = " The quotient value would be too large to be held in a `u64`"] const EDIVISION : u64 = 0x20002 ; # [doc = " The multiplied value would be too large to be held in a `u64`"] const EMULTIPLICATION : u64 = 0x20003 ; # [doc = " A division by zero was encountered"] const EDIVISION_BY_ZERO : u64 = 0x10004 ; # [doc = " The computed ratio when converting to a `FixedPoint32` would be unrepresentable"] const ERATIO_OUT_OF_RANGE : u64 = 0x20005 ; # [doc = " Multiply a u64 integer by a fixed-point number, truncating any"] # [doc = " fractional part of the product. This will abort if the product"] # [doc = " overflows."] public fun multiply_u64 (val : u64 , multiplier : FixedPoint32) : u64 { let unscaled_product = val as u128 * (multiplier . value as u128) ; let product = unscaled_product >> 32 ; assert ! (product <= MAX_U64 , EMULTIPLICATION) ; product as u64 } # [doc = " Divide a u64 integer by a fixed-point number, truncating any"] # [doc = " fractional part of the quotient. This will abort if the divisor"] # [doc = " is zero or if the quotient overflows."] public fun divide_u64 (val : u64 , divisor : FixedPoint32) : u64 { assert ! (divisor . value != 0 , EDIVISION_BY_ZERO) ; let scaled_value = val as u128 << 32 ; let quotient = scaled_value / (divisor . value as u128) ; assert ! (quotient <= MAX_U64 , EDIVISION) ; quotient as u64 } # [doc = " Create a fixed-point value from a rational number specified by its"] # [doc = " numerator and denominator. Calling this function should be preferred"] # [doc = " for using `Self::create_from_raw_value` which is also available."] # [doc = " This will abort if the denominator is zero. It will also"] # [doc = " abort if the numerator is nonzero and the ratio is not in the range"] # [doc = " 2^-32 .. 2^32-1. When specifying decimal fractions, be careful about"] # [doc = " rounding errors: if you round to display N digits after the decimal"] # [doc = " point, you can use a denominator of 10^N to avoid numbers where the"] # [doc = " very small imprecision in the binary representation could change the"] # [doc = " rounding, e.g., 0.0125 will round down to 0.012 instead of up to 0.013."] public fun create_from_rational (numerator : u64 , denominator : u64) : FixedPoint32 { let scaled_numerator = numerator as u128 << 64 ; let scaled_denominator = denominator as u128 << 32 ; assert ! (scaled_denominator != 0 , EDENOMINATOR) ; let quotient = scaled_numerator / scaled_denominator ; assert ! (quotient != 0 || numerator == 0 , ERATIO_OUT_OF_RANGE) ; assert ! (quotient <= MAX_U64 , ERATIO_OUT_OF_RANGE) ; FixedPoint32 { value : quotient as u64 } } # [doc = " Create a fixedpoint value from a raw value."] public fun create_from_raw_value (value : u64) : FixedPoint32 { FixedPoint32 { value } } # [doc = " Accessor for the raw u64 value. Other less common operations, such as"] # [doc = " adding or subtracting FixedPoint32 values, can be done using the raw"] # [doc = " values directly."] public fun get_raw_value (num : FixedPoint32) : u64 { num . value } # [doc = " Returns true if the ratio is zero."] public fun is_zero (num : FixedPoint32) : bool { num . value == 0 }
