---
source: crates/move-syn/tests/sui-framework.rs
expression: ast.tokens_to_string()
---
# [allow (unused_use)] module sui :: authenticator_state ; use std :: string :: { Self , String , utf8 } ; use sui :: dynamic_field ; # [doc = " Sender is not @0x0 the system address."] const ENotSystemAddress : u64 = 0 ; const EWrongInnerVersion : u64 = 1 ; const EJwksNotSorted : u64 = 2 ; const CurrentVersion : u64 = 1 ; # [doc = " Singleton shared object which stores the global authenticator state."] # [doc = " The actual state is stored in a dynamic field of type AuthenticatorStateInner to support"] # [doc = " future versions of the authenticator state."] public struct AuthenticatorState has key { id : UID , version : u64 , } public struct AuthenticatorStateInner has store { version : u64 , # [doc = " List of currently active JWKs."] active_jwks : vector < ActiveJwk > , } # [allow (unused_field)] # [doc = " Must match the JWK struct in fastcrypto-zkp"] public struct JWK has copy , drop , store { kty : String , e : String , n : String , alg : String , } # [allow (unused_field)] # [doc = " Must match the JwkId struct in fastcrypto-zkp"] public struct JwkId has copy , drop , store { iss : String , kid : String , } # [allow (unused_field)] public struct ActiveJwk has copy , drop , store { jwk_id : JwkId , jwk : JWK , epoch : u64 , } # [test_only] public fun create_active_jwk (iss : String , kid : String , kty : String , epoch : u64) : ActiveJwk { ActiveJwk { jwk_id : JwkId { iss : iss , kid : kid , } , jwk : JWK { kty : kty , e : utf8 (b"AQAB") , n : utf8 (b"test") , alg : utf8 (b"RS256") , } , epoch , } } fun active_jwk_equal (a : & ActiveJwk , b : & ActiveJwk) : bool { jwk_equal (& a . jwk , & b . jwk) && jwk_id_equal (& a . jwk_id , & b . jwk_id) } fun jwk_equal (a : & JWK , b : & JWK) : bool { (& a . kty == & b . kty) && (& a . e == & b . e) && (& a . n == & b . n) && (& a . alg == & b . alg) } fun jwk_id_equal (a : & JwkId , b : & JwkId) : bool { (& a . iss == & b . iss) && (& a . kid == & b . kid) } fun string_bytes_lt (a : & String , b : & String) : bool { let a_bytes = a . as_bytes () ; let b_bytes = b . as_bytes () ; if (a_bytes . length () < b_bytes . length ()) { true } else if (a_bytes . length () > b_bytes . length ()) { false } else { let mut i = 0 ; while (i < a_bytes . length ()) { let a_byte = a_bytes [i] ; let b_byte = b_bytes [i] ; if (a_byte < b_byte) { return true } else if (a_byte > b_byte) { return false } ; i = i + 1 ; } ; false } } fun jwk_lt (a : & ActiveJwk , b : & ActiveJwk) : bool { if (& a . jwk_id . iss != & b . jwk_id . iss) { return string_bytes_lt (& a . jwk_id . iss , & b . jwk_id . iss) } ; if (& a . jwk_id . kid != & b . jwk_id . kid) { return string_bytes_lt (& a . jwk_id . kid , & b . jwk_id . kid) } ; if (& a . jwk . kty != & b . jwk . kty) { return string_bytes_lt (& a . jwk . kty , & b . jwk . kty) } ; if (& a . jwk . e != & b . jwk . e) { return string_bytes_lt (& a . jwk . e , & b . jwk . e) } ; if (& a . jwk . n != & b . jwk . n) { return string_bytes_lt (& a . jwk . n , & b . jwk . n) } ; string_bytes_lt (& a . jwk . alg , & b . jwk . alg) } # [allow (unused_function)] # [doc = " Create and share the AuthenticatorState object. This function is call exactly once, when"] # [doc = " the authenticator state object is first created."] # [doc = " Can only be called by genesis or change_epoch transactions."] fun create (ctx : & TxContext) { assert ! (ctx . sender () == @ 0x0 , ENotSystemAddress) ; let version = CurrentVersion ; let inner = AuthenticatorStateInner { version , active_jwks : vector [] , } ; let mut self = AuthenticatorState { id : object :: authenticator_state () , version , } ; dynamic_field :: add (& mut self . id , version , inner) ; transfer :: share_object (self) ; } fun load_inner_mut (self : & mut AuthenticatorState) : & mut AuthenticatorStateInner { let version = self . version ; assert ! (version == CurrentVersion , EWrongInnerVersion) ; let inner : & mut AuthenticatorStateInner = dynamic_field :: borrow_mut (& mut self . id , self . version) ; assert ! (inner . version == version , EWrongInnerVersion) ; inner } fun load_inner (self : & AuthenticatorState) : & AuthenticatorStateInner { let version = self . version ; assert ! (version == CurrentVersion , EWrongInnerVersion) ; let inner : & AuthenticatorStateInner = dynamic_field :: borrow (& self . id , self . version) ; assert ! (inner . version == version , EWrongInnerVersion) ; inner } fun check_sorted (new_active_jwks : & vector < ActiveJwk >) { let mut i = 0 ; while (i < new_active_jwks . length () - 1) { let a = & new_active_jwks [i] ; let b = & new_active_jwks [i + 1] ; assert ! (jwk_lt (a , b) , EJwksNotSorted) ; i = i + 1 ; } ; } # [allow (unused_function)] # [doc = " Record a new set of active_jwks. Called when executing the AuthenticatorStateUpdate system"] # [doc = " transaction. The new input vector must be sorted and must not contain duplicates."] # [doc = " If a new JWK is already present, but with a previous epoch, then the epoch is updated to"] # [doc = " indicate that the JWK has been validated in the current epoch and should not be expired."] fun update_authenticator_state (self : & mut AuthenticatorState , new_active_jwks : vector < ActiveJwk > , ctx : & TxContext ,) { assert ! (ctx . sender () == @ 0x0 , ENotSystemAddress) ; check_sorted (& new_active_jwks) ; let new_active_jwks = deduplicate (new_active_jwks) ; let inner = self . load_inner_mut () ; let mut res = vector [] ; let mut i = 0 ; let mut j = 0 ; let active_jwks_len = inner . active_jwks . length () ; let new_active_jwks_len = new_active_jwks . length () ; while (i < active_jwks_len && j < new_active_jwks_len) { let old_jwk = & inner . active_jwks [i] ; let new_jwk = & new_active_jwks [j] ; if (active_jwk_equal (old_jwk , new_jwk)) { let mut jwk = * old_jwk ; jwk . epoch = old_jwk . epoch . max (new_jwk . epoch) ; res . push_back (jwk) ; i = i + 1 ; j = j + 1 ; } else if (jwk_id_equal (& old_jwk . jwk_id , & new_jwk . jwk_id)) { res . push_back (* old_jwk) ; i = i + 1 ; j = j + 1 ; } else if (jwk_lt (old_jwk , new_jwk)) { res . push_back (* old_jwk) ; i = i + 1 ; } else { res . push_back (* new_jwk) ; j = j + 1 ; } } ; while (i < active_jwks_len) { res . push_back (inner . active_jwks [i]) ; i = i + 1 ; } ; while (j < new_active_jwks_len) { res . push_back (new_active_jwks [j]) ; j = j + 1 ; } ; inner . active_jwks = res ; } fun deduplicate (jwks : vector < ActiveJwk >) : vector < ActiveJwk > { let mut res = vector [] ; let mut i = 0 ; let mut prev : Option < JwkId > = option :: none () ; while (i < jwks . length ()) { let jwk = & jwks [i] ; if (prev . is_none ()) { prev . fill (jwk . jwk_id) ; } else if (jwk_id_equal (prev . borrow () , & jwk . jwk_id)) { i = i + 1 ; continue } else { * prev . borrow_mut () = jwk . jwk_id ; } ; res . push_back (* jwk) ; i = i + 1 ; } ; res } # [allow (unused_function)] fun expire_jwks (self : & mut AuthenticatorState , min_epoch : u64 , ctx : & TxContext ,) { assert ! (ctx . sender () == @ 0x0 , ENotSystemAddress) ; let inner = load_inner_mut (self) ; let len = inner . active_jwks . length () ; let mut issuer_max_epochs = vector [] ; let mut i = 0 ; let mut prev_issuer : Option < String > = option :: none () ; while (i < len) { let cur = & inner . active_jwks [i] ; let cur_iss = & cur . jwk_id . iss ; if (prev_issuer . is_none ()) { prev_issuer . fill (* cur_iss) ; issuer_max_epochs . push_back (cur . epoch) ; } else { if (cur_iss == prev_issuer . borrow ()) { let back = issuer_max_epochs . length () - 1 ; let prev_max_epoch = & mut issuer_max_epochs [back] ; * prev_max_epoch = (* prev_max_epoch) . max (cur . epoch) ; } else { * prev_issuer . borrow_mut () = * cur_iss ; issuer_max_epochs . push_back (cur . epoch) ; } } ; i = i + 1 ; } ; let mut new_active_jwks : vector < ActiveJwk > = vector [] ; let mut prev_issuer : Option < String > = option :: none () ; let mut i = 0 ; let mut j = 0 ; while (i < len) { let jwk = & inner . active_jwks [i] ; let cur_iss = & jwk . jwk_id . iss ; if (prev_issuer . is_none ()) { prev_issuer . fill (* cur_iss) ; } else if (cur_iss != prev_issuer . borrow ()) { * prev_issuer . borrow_mut () = * cur_iss ; j = j + 1 ; } ; let max_epoch_for_iss = & issuer_max_epochs [j] ; if (* max_epoch_for_iss < min_epoch || jwk . epoch >= min_epoch) { new_active_jwks . push_back (* jwk) ; } ; i = i + 1 ; } ; inner . active_jwks = new_active_jwks ; } # [allow (unused_function)] # [doc = " Get the current active_jwks. Called when the node starts up in order to load the current"] # [doc = " JWK state from the chain."] fun get_active_jwks (self : & AuthenticatorState , ctx : & TxContext) : vector < ActiveJwk > { assert ! (ctx . sender () == @ 0x0 , ENotSystemAddress) ; self . load_inner () . active_jwks } # [test_only] public fun create_for_testing (ctx : & TxContext) { create (ctx) ; } # [test_only] public fun update_authenticator_state_for_testing (self : & mut AuthenticatorState , new_active_jwks : vector < ActiveJwk > , ctx : & TxContext ,) { self . update_authenticator_state (new_active_jwks , ctx) ; } # [test_only] public fun expire_jwks_for_testing (self : & mut AuthenticatorState , min_epoch : u64 , ctx : & TxContext) { self . expire_jwks (min_epoch , ctx) ; } # [test_only] public fun get_active_jwks_for_testing (self : & AuthenticatorState , ctx : & TxContext ,) : vector < ActiveJwk > { self . get_active_jwks (ctx) }
