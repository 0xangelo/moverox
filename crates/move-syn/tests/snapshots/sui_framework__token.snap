---
source: crates/move-syn/tests/sui-framework.rs
expression: ast.tokens_to_string()
---
# [doc = " The Token module which implements a Closed Loop Token with a configurable"] # [doc = " policy. The policy is defined by a set of rules that must be satisfied for"] # [doc = " an action to be performed on the token."] # [doc = ""] # [doc = " The module is designed to be used with a `TreasuryCap` to allow for minting"] # [doc = " and burning of the `Token`s. And can act as a replacement / extension or a"] # [doc = " companion to existing open-loop (`Coin`) systems."] # [doc = ""] # [doc = " ```"] # [doc = " Module:      sui::balance       sui::coin             sui::token"] # [doc = " Main type:   Balance<T>         Coin<T>               Token<T>"] # [doc = " Capability:  Supply<T>  <---->  TreasuryCap<T> <----> TreasuryCap<T>"] # [doc = " Abilities:   store              key + store           key"] # [doc = " ```"] # [doc = ""] # [doc = " The Token system allows for fine-grained control over the actions performed"] # [doc = " on the token. And hence it is highly suitable for applications that require"] # [doc = " control over the currency which a simple open-loop system can't provide."] module sui :: token ; use std :: string :: String ; use std :: type_name :: { Self , TypeName } ; use sui :: balance :: { Self , Balance } ; use sui :: coin :: { Coin , TreasuryCap } ; use sui :: dynamic_field as df ; use sui :: event ; use sui :: vec_map :: { Self , VecMap } ; use sui :: vec_set :: { Self , VecSet } ; # [doc = " The action is not allowed (defined) in the policy."] const EUnknownAction : u64 = 0 ; # [doc = " The rule was not approved."] const ENotApproved : u64 = 1 ; # [doc = " Trying to perform an admin action with a wrong cap."] const ENotAuthorized : u64 = 2 ; # [doc = " The balance is too low to perform the action."] const EBalanceTooLow : u64 = 3 ; # [doc = " The balance is not zero."] const ENotZero : u64 = 4 ; # [doc = " The balance is not zero when trying to confirm with `TransferPolicyCap`."] const ECantConsumeBalance : u64 = 5 ; # [doc = " Rule is trying to access a missing config (with type)."] const ENoConfig : u64 = 6 ; # [doc = " Using `confirm_request_mut` without `spent_balance`. Immutable version"] # [doc = " of the function must be used instead."] const EUseImmutableConfirm : u64 = 7 ; # [doc = " A Tag for the `spend` action."] const SPEND : vector < u8 > = b"spend" ; # [doc = " A Tag for the `transfer` action."] const TRANSFER : vector < u8 > = b"transfer" ; # [doc = " A Tag for the `to_coin` action."] const TO_COIN : vector < u8 > = b"to_coin" ; # [doc = " A Tag for the `from_coin` action."] const FROM_COIN : vector < u8 > = b"from_coin" ; # [doc = " A single `Token` with `Balance` inside. Can only be owned by an address,"] # [doc = " and actions performed on it must be confirmed in a matching `TokenPolicy`."] public struct Token < phantom T > has key { id : UID , # [doc = " The Balance of the `Token`."] balance : Balance < T > , } # [doc = " A Capability that manages a single `TokenPolicy` specified in the `for`"] # [doc = " field. Created together with `TokenPolicy` in the `new` function."] public struct TokenPolicyCap < phantom T > has key , store { id : UID , for : ID } # [doc = " `TokenPolicy` represents a set of rules that define what actions can be"] # [doc = " performed on a `Token` and which `Rules` must be satisfied for the"] # [doc = " action to succeed."] # [doc = ""] # [doc = " - For the sake of availability, `TokenPolicy` is a `key`-only object."] # [doc = " - Each `TokenPolicy` is managed by a matching `TokenPolicyCap`."] # [doc = " - For an action to become available, there needs to be a record in the"] # [doc = " `rules` VecMap. To allow an action to be performed freely, there's an"] # [doc = " `allow` function that can be called by the `TokenPolicyCap` owner."] public struct TokenPolicy < phantom T > has key { id : UID , # [doc = " The balance that is effectively spent by the user on the \"spend\""] # [doc = " action. However, actual decrease of the supply can only be done by"] # [doc = " the `TreasuryCap` owner when `flush` is called."] # [doc = ""] # [doc = " This balance is effectively spent and cannot be accessed by anyone"] # [doc = " but the `TreasuryCap` owner."] spent_balance : Balance < T > , # [doc = " The set of rules that define what actions can be performed on the"] # [doc = " token. For each \"action\" there's a set of Rules that must be"] # [doc = " satisfied for the `ActionRequest` to be confirmed."] rules : VecMap < String , VecSet < TypeName > > , } # [doc = " A request to perform an \"Action\" on a token. Stores the information"] # [doc = " about the action to be performed and must be consumed by the `confirm_request`"] # [doc = " or `confirm_request_mut` functions when the Rules are satisfied."] public struct ActionRequest < phantom T > { # [doc = " Name of the Action to look up in the Policy. Name can be one of the"] # [doc = " default actions: `transfer`, `spend`, `to_coin`, `from_coin` or a"] # [doc = " custom action."] name : String , # [doc = " Amount is present in all of the txs"] amount : u64 , # [doc = " Sender is a permanent field always"] sender : address , # [doc = " Recipient is only available in `transfer` action."] recipient : Option < address > , # [doc = " The balance to be \"spent\" in the `TokenPolicy`, only available"] # [doc = " in the `spend` action."] spent_balance : Option < Balance < T > > , # [doc = " Collected approvals (stamps) from completed `Rules`. They're matched"] # [doc = " against `TokenPolicy.rules` to determine if the request can be"] # [doc = " confirmed."] approvals : VecSet < TypeName > , } # [doc = " Dynamic field key for the `TokenPolicy` to store the `Config` for a"] # [doc = " specific action `Rule`. There can be only one configuration per"] # [doc = " `Rule` per `TokenPolicy`."] public struct RuleKey < phantom T > has copy , drop , store { is_protected : bool } # [doc = " An event emitted when a `TokenPolicy` is created and shared. Because"] # [doc = " `TokenPolicy` can only be shared (and potentially frozen in the future),"] # [doc = " we emit this event in the `share_policy` function and mark it as mutable."] public struct TokenPolicyCreated < phantom T > has copy , drop { # [doc = " ID of the `TokenPolicy` that was created."] id : ID , # [doc = " Whether the `TokenPolicy` is \"shared\" (mutable) or \"frozen\""] # [doc = " (immutable) - TBD."] is_mutable : bool , } # [doc = " Create a new `TokenPolicy` and a matching `TokenPolicyCap`."] # [doc = " The `TokenPolicy` must then be shared using the `share_policy` method."] # [doc = ""] # [doc = " `TreasuryCap` guarantees full ownership over the currency, and is unique,"] # [doc = " hence it is safe to use it for authorization."] public fun new_policy < T > (_treasury_cap : & TreasuryCap < T >, ctx : & mut TxContext ,) : (TokenPolicy < T >, TokenPolicyCap < T >) { let policy = TokenPolicy { id : object :: new (ctx) , spent_balance : balance :: zero () , rules : vec_map :: empty () , } ; let cap = TokenPolicyCap { id : object :: new (ctx) , for : object :: id (& policy) , } ; (policy , cap) } # [doc = " Share the `TokenPolicy`. Due to `key`-only restriction, it must be"] # [doc = " shared after initialization."] public fun share_policy < T > (policy : TokenPolicy < T >) { event :: emit (TokenPolicyCreated < T > { id : object :: id (& policy) , is_mutable : true , }) ; transfer :: share_object (policy) } # [doc = " Transfer a `Token` to a `recipient`. Creates an `ActionRequest` for the"] # [doc = " \"transfer\" action. The `ActionRequest` contains the `recipient` field"] # [doc = " to be used in verification."] public fun transfer < T > (t : Token < T >, recipient : address , ctx : & mut TxContext) : ActionRequest < T > { let amount = t . balance . value () ; transfer :: transfer (t , recipient) ; new_request (transfer_action () , amount , option :: some (recipient) , option :: none () , ctx ,) } # [doc = " Spend a `Token` by unwrapping it and storing the `Balance` in the"] # [doc = " `ActionRequest` for the \"spend\" action. The `ActionRequest` contains"] # [doc = " the `spent_balance` field to be used in verification."] # [doc = ""] # [doc = " Spend action requires `confirm_request_mut` to be called to confirm the"] # [doc = " request and join the spent balance with the `TokenPolicy.spent_balance`."] public fun spend < T > (t : Token < T >, ctx : & mut TxContext) : ActionRequest < T > { let Token { id , balance } = t ; id . delete () ; new_request (spend_action () , balance . value () , option :: none () , option :: some (balance) , ctx ,) } # [doc = " Convert `Token` into an open `Coin`. Creates an `ActionRequest` for the"] # [doc = " \"to_coin\" action."] public fun to_coin < T > (t : Token < T >, ctx : & mut TxContext) : (Coin < T >, ActionRequest < T >) { let Token { id , balance } = t ; let amount = balance . value () ; id . delete () ; (balance . into_coin (ctx) , new_request (to_coin_action () , amount , option :: none () , option :: none () , ctx ,) ,) } # [doc = " Convert an open `Coin` into a `Token`. Creates an `ActionRequest` for"] # [doc = " the \"from_coin\" action."] public fun from_coin < T > (coin : Coin < T >, ctx : & mut TxContext) : (Token < T >, ActionRequest < T >) { let amount = coin . value () ; let token = Token { id : object :: new (ctx) , balance : coin . into_balance () , } ; (token , new_request (from_coin_action () , amount , option :: none () , option :: none () , ctx ,) ,) } # [doc = " Join two `Token`s into one, always available."] public fun join < T > (token : & mut Token < T >, another : Token < T >) { let Token { id , balance } = another ; token . balance . join (balance) ; id . delete () ; } # [doc = " Split a `Token` with `amount`."] # [doc = " Aborts if the `Token.balance` is lower than `amount`."] public fun split < T > (token : & mut Token < T >, amount : u64 , ctx : & mut TxContext) : Token < T > { assert ! (token . balance . value () >= amount , EBalanceTooLow) ; Token { id : object :: new (ctx) , balance : token . balance . split (amount) , } } # [doc = " Create a zero `Token`."] public fun zero < T > (ctx : & mut TxContext) : Token < T > { Token { id : object :: new (ctx) , balance : balance :: zero () , } } # [doc = " Destroy an empty `Token`, fails if the balance is non-zero."] # [doc = " Aborts if the `Token.balance` is not zero."] public fun destroy_zero < T > (token : Token < T >) { let Token { id , balance } = token ; assert ! (balance . value () == 0 , ENotZero) ; balance . destroy_zero () ; id . delete () ; } # [allow (lint (self_transfer))] # [doc = " Transfer the `Token` to the transaction sender."] public fun keep < T > (token : Token < T >, ctx : & mut TxContext) { transfer :: transfer (token , ctx . sender ()) } # [doc = " Create a new `ActionRequest`."] # [doc = " Publicly available method to allow for custom actions."] public fun new_request < T > (name : String , amount : u64 , recipient : Option < address >, spent_balance : Option < Balance < T >>, ctx : & TxContext ,) : ActionRequest < T > { ActionRequest { name , amount , recipient , spent_balance , sender : ctx . sender () , approvals : vec_set :: empty () , } } # [doc = " Confirm the request against the `TokenPolicy` and return the parameters"] # [doc = " of the request: (Name, Amount, Sender, Recipient)."] # [doc = ""] # [doc = " Cannot be used for `spend` and similar actions that deliver `spent_balance`"] # [doc = " to the `TokenPolicy`. For those actions use `confirm_request_mut`."] # [doc = ""] # [doc = " Aborts if:"] # [doc = " - the action is not allowed (missing record in `rules`)"] # [doc = " - action contains `spent_balance` (use `confirm_request_mut`)"] # [doc = " - the `ActionRequest` does not meet the `TokenPolicy` rules for the action"] public fun confirm_request < T > (policy : & TokenPolicy < T >, request : ActionRequest < T >, _ctx : & mut TxContext ,) : (String , u64 , address , Option < address >) { assert ! (request . spent_balance . is_none () , ECantConsumeBalance) ; assert ! (policy . rules . contains (& request . name) , EUnknownAction) ; let ActionRequest { name , approvals , spent_balance , amount , sender , recipient , } = request ; spent_balance . destroy_none () ; let rules = & (* policy . rules . get (& name)) . into_keys () ; let rules_len = rules . length () ; let mut i = 0 ; while (i < rules_len) { let rule = & rules [i] ; assert ! (approvals . contains (rule) , ENotApproved) ; i = i + 1 ; } ; (name , amount , sender , recipient) } # [doc = " Confirm the request against the `TokenPolicy` and return the parameters"] # [doc = " of the request: (Name, Amount, Sender, Recipient)."] # [doc = ""] # [doc = " Unlike `confirm_request` this function requires mutable access to the"] # [doc = " `TokenPolicy` and must be used on `spend` action. After dealing with the"] # [doc = " spent balance it calls `confirm_request` internally."] # [doc = ""] # [doc = " See `confirm_request` for the list of abort conditions."] public fun confirm_request_mut < T > (policy : & mut TokenPolicy < T >, mut request : ActionRequest < T >, ctx : & mut TxContext ,) : (String , u64 , address , Option < address >) { assert ! (policy . rules . contains (& request . name) , EUnknownAction) ; assert ! (request . spent_balance . is_some () , EUseImmutableConfirm) ; policy . spent_balance . join (request . spent_balance . extract ()) ; confirm_request (policy , request , ctx) } # [doc = " Confirm an `ActionRequest` as the `TokenPolicyCap` owner. This function"] # [doc = " allows `TokenPolicy` owner to perform Capability-gated actions ignoring"] # [doc = " the ruleset specified in the `TokenPolicy`."] # [doc = ""] # [doc = " Aborts if request contains `spent_balance` due to inability of the"] # [doc = " `TokenPolicyCap` to decrease supply. For scenarios like this a"] # [doc = " `TreasuryCap` is required (see `confirm_with_treasury_cap`)."] public fun confirm_with_policy_cap < T > (_policy_cap : & TokenPolicyCap < T >, request : ActionRequest < T >, _ctx : & mut TxContext ,) : (String , u64 , address , Option < address >) { assert ! (request . spent_balance . is_none () , ECantConsumeBalance) ; let ActionRequest { name , amount , sender , recipient , approvals : _ , spent_balance , } = request ; spent_balance . destroy_none () ; (name , amount , sender , recipient) } # [doc = " Confirm an `ActionRequest` as the `TreasuryCap` owner. This function"] # [doc = " allows `TreasuryCap` owner to perform Capability-gated actions ignoring"] # [doc = " the ruleset specified in the `TokenPolicy`."] # [doc = ""] # [doc = " Unlike `confirm_with_policy_cap` this function allows `spent_balance`"] # [doc = " to be consumed, decreasing the `total_supply` of the `Token`."] public fun confirm_with_treasury_cap < T > (treasury_cap : & mut TreasuryCap < T >, request : ActionRequest < T >, _ctx : & mut TxContext ,) : (String , u64 , address , Option < address >) { let ActionRequest { name , amount , sender , recipient , approvals : _ , spent_balance , } = request ; if (spent_balance . is_some ()) { treasury_cap . supply_mut () . decrease_supply (spent_balance . destroy_some ()) ; } else { spent_balance . destroy_none () ; } ; (name , amount , sender , recipient) } # [doc = " Add an \"approval\" to the `ActionRequest` by providing a Witness."] # [doc = " Intended to be used by Rules to add their own approvals, however, can"] # [doc = " be used to add arbitrary approvals to the request (not only the ones"] # [doc = " required by the `TokenPolicy`)."] public fun add_approval < T , W : drop > (_t : W , request : & mut ActionRequest < T >, _ctx : & mut TxContext) { request . approvals . insert (type_name :: get < W > ()) } # [doc = " Add a `Config` for a `Rule` in the `TokenPolicy`. Rule configuration is"] # [doc = " independent from the `TokenPolicy.rules` and needs to be managed by the"] # [doc = " Rule itself. Configuration is stored per `Rule` and not per `Rule` per"] # [doc = " `Action` to allow reuse in different actions."] # [doc = ""] # [doc = " - Rule witness guarantees that the `Config` is approved by the Rule."] # [doc = " - `TokenPolicyCap` guarantees that the `Config` setup is initiated by"] # [doc = " the `TokenPolicy` owner."] public fun add_rule_config < T , Rule : drop , Config : store > (_rule : Rule , self : & mut TokenPolicy < T >, cap : & TokenPolicyCap < T >, config : Config , _ctx : & mut TxContext ,) { assert ! (object :: id (self) == cap . for , ENotAuthorized) ; df :: add (& mut self . id , key < Rule > () , config) } # [doc = " Get a `Config` for a `Rule` in the `TokenPolicy`. Requires `Rule`"] # [doc = " witness, hence can only be read by the `Rule` itself. This requirement"] # [doc = " guarantees safety of the stored `Config` and allows for simpler dynamic"] # [doc = " field management inside the Rule Config (custom type keys are not needed"] # [doc = " for access gating)."] # [doc = ""] # [doc = " Aborts if the Config is not present."] public fun rule_config < T , Rule : drop , Config : store > (_rule : Rule , self : & TokenPolicy < T >) : & Config { assert ! (has_rule_config_with_type < T , Rule , Config > (self) , ENoConfig) ; df :: borrow (& self . id , key < Rule > ()) } # [doc = " Get mutable access to the `Config` for a `Rule` in the `TokenPolicy`."] # [doc = " Requires `Rule` witness, hence can only be read by the `Rule` itself,"] # [doc = " as well as `TokenPolicyCap` to guarantee that the `TokenPolicy` owner"] # [doc = " is the one who initiated the `Config` modification."] # [doc = ""] # [doc = " Aborts if:"] # [doc = " - the Config is not present"] # [doc = " - `TokenPolicyCap` is not matching the `TokenPolicy`"] public fun rule_config_mut < T , Rule : drop , Config : store > (_rule : Rule , self : & mut TokenPolicy < T >, cap : & TokenPolicyCap < T >,) : & mut Config { assert ! (has_rule_config_with_type < T , Rule , Config > (self) , ENoConfig) ; assert ! (object :: id (self) == cap . for , ENotAuthorized) ; df :: borrow_mut (& mut self . id , key < Rule > ()) } # [doc = " Remove a `Config` for a `Rule` in the `TokenPolicy`."] # [doc = " Unlike the `add_rule_config`, this function does not require a `Rule`"] # [doc = " witness, hence can be performed by the `TokenPolicy` owner on their own."] # [doc = ""] # [doc = " Rules need to make sure that the `Config` is present when performing"] # [doc = " verification of the `ActionRequest`."] # [doc = ""] # [doc = " Aborts if:"] # [doc = " - the Config is not present"] # [doc = " - `TokenPolicyCap` is not matching the `TokenPolicy`"] public fun remove_rule_config < T , Rule , Config : store > (self : & mut TokenPolicy < T >, cap : & TokenPolicyCap < T >, _ctx : & mut TxContext ,) : Config { assert ! (has_rule_config_with_type < T , Rule , Config > (self) , ENoConfig) ; assert ! (object :: id (self) == cap . for , ENotAuthorized) ; df :: remove (& mut self . id , key < Rule > ()) } # [doc = " Check if a config for a `Rule` is set in the `TokenPolicy` without"] # [doc = " checking the type of the `Config`."] public fun has_rule_config < T , Rule > (self : & TokenPolicy < T >) : bool { df :: exists_ < RuleKey < Rule >> (& self . id , key < Rule > ()) } # [doc = " Check if a `Config` for a `Rule` is set in the `TokenPolicy` and that"] # [doc = " it matches the type provided."] public fun has_rule_config_with_type < T , Rule , Config : store > (self : & TokenPolicy < T >) : bool { df :: exists_with_type < RuleKey < Rule >, Config > (& self . id , key < Rule > ()) } # [doc = " Allows an `action` to be performed on the `Token` freely by adding an"] # [doc = " empty set of `Rules` for the `action`."] # [doc = ""] # [doc = " Aborts if the `TokenPolicyCap` is not matching the `TokenPolicy`."] public fun allow < T > (self : & mut TokenPolicy < T >, cap : & TokenPolicyCap < T >, action : String , _ctx : & mut TxContext ,) { assert ! (object :: id (self) == cap . for , ENotAuthorized) ; self . rules . insert (action , vec_set :: empty ()) ; } # [doc = " Completely disallows an `action` on the `Token` by removing the record"] # [doc = " from the `TokenPolicy.rules`."] # [doc = ""] # [doc = " Aborts if the `TokenPolicyCap` is not matching the `TokenPolicy`."] public fun disallow < T > (self : & mut TokenPolicy < T >, cap : & TokenPolicyCap < T >, action : String , _ctx : & mut TxContext ,) { assert ! (object :: id (self) == cap . for , ENotAuthorized) ; self . rules . remove (& action) ; } # [doc = " Adds a Rule for an action with `name` in the `TokenPolicy`."] # [doc = ""] # [doc = " Aborts if the `TokenPolicyCap` is not matching the `TokenPolicy`."] public fun add_rule_for_action < T , Rule : drop > (self : & mut TokenPolicy < T >, cap : & TokenPolicyCap < T >, action : String , ctx : & mut TxContext ,) { assert ! (object :: id (self) == cap . for , ENotAuthorized) ; if (! self . rules . contains (& action)) { allow (self , cap , action , ctx) ; } ; self . rules . get_mut (& action) . insert (type_name :: get < Rule > ()) } # [doc = " Removes a rule for an action with `name` in the `TokenPolicy`. Returns"] # [doc = " the config object to be handled by the sender (or a Rule itself)."] # [doc = ""] # [doc = " Aborts if the `TokenPolicyCap` is not matching the `TokenPolicy`."] public fun remove_rule_for_action < T , Rule : drop > (self : & mut TokenPolicy < T >, cap : & TokenPolicyCap < T >, action : String , _ctx : & mut TxContext ,) { assert ! (object :: id (self) == cap . for , ENotAuthorized) ; self . rules . get_mut (& action) . remove (& type_name :: get < Rule > ()) } # [doc = " Mint a `Token` with a given `amount` using the `TreasuryCap`."] public fun mint < T > (cap : & mut TreasuryCap < T >, amount : u64 , ctx : & mut TxContext) : Token < T > { let balance = cap . supply_mut () . increase_supply (amount) ; Token { id : object :: new (ctx) , balance } } # [doc = " Burn a `Token` using the `TreasuryCap`."] public fun burn < T > (cap : & mut TreasuryCap < T >, token : Token < T >) { let Token { id , balance } = token ; cap . supply_mut () . decrease_supply (balance) ; id . delete () ; } # [doc = " Flush the `TokenPolicy.spent_balance` into the `TreasuryCap`. This"] # [doc = " action is only available to the `TreasuryCap` owner."] public fun flush < T > (self : & mut TokenPolicy < T >, cap : & mut TreasuryCap < T >, _ctx : & mut TxContext ,) : u64 { let amount = self . spent_balance . value () ; let balance = self . spent_balance . split (amount) ; cap . supply_mut () . decrease_supply (balance) } # [doc = " Check whether an action is present in the rules VecMap."] public fun is_allowed < T > (self : & TokenPolicy < T >, action : & String) : bool { self . rules . contains (action) } # [doc = " Returns the rules required for a specific action."] public fun rules < T > (self : & TokenPolicy < T >, action : & String) : VecSet < TypeName > { * self . rules . get (action) } # [doc = " Returns the `spent_balance` of the `TokenPolicy`."] public fun spent_balance < T > (self : & TokenPolicy < T >) : u64 { self . spent_balance . value () } # [doc = " Returns the `balance` of the `Token`."] public fun value < T > (t : & Token < T >) : u64 { t . balance . value () } # [doc = " Name of the Transfer action."] public fun transfer_action () : String { let transfer_str = TRANSFER ; transfer_str . to_string () } # [doc = " Name of the `Spend` action."] public fun spend_action () : String { let spend_str = SPEND ; spend_str . to_string () } # [doc = " Name of the `ToCoin` action."] public fun to_coin_action () : String { let to_coin_str = TO_COIN ; to_coin_str . to_string () } # [doc = " Name of the `FromCoin` action."] public fun from_coin_action () : String { let from_coin_str = FROM_COIN ; from_coin_str . to_string () } # [doc = " The Action in the `ActionRequest`."] public fun action < T > (self : & ActionRequest < T >) : String { self . name } # [doc = " Amount of the `ActionRequest`."] public fun amount < T > (self : & ActionRequest < T >) : u64 { self . amount } # [doc = " Sender of the `ActionRequest`."] public fun sender < T > (self : & ActionRequest < T >) : address { self . sender } # [doc = " Recipient of the `ActionRequest`."] public fun recipient < T > (self : & ActionRequest < T >) : Option < address > { self . recipient } # [doc = " Approvals of the `ActionRequest`."] public fun approvals < T > (self : & ActionRequest < T >) : VecSet < TypeName > { self . approvals } # [doc = " Burned balance of the `ActionRequest`."] public fun spent < T > (self : & ActionRequest < T >) : Option < u64 > { if (self . spent_balance . is_some ()) { option :: some (self . spent_balance . borrow () . value ()) } else { option :: none () } } # [doc = " Create a new `RuleKey` for a `Rule`. The `is_protected` field is kept"] # [doc = " for potential future use, if Rules were to have a freely modifiable"] # [doc = " storage as addition / replacement for the `Config` system."] # [doc = ""] # [doc = " The goal of `is_protected` is to potentially allow Rules store a mutable"] # [doc = " version of their configuration and mutate state on user action."] fun key < Rule > () : RuleKey < Rule > { RuleKey { is_protected : true } } # [test_only] public fun new_policy_for_testing < T > (ctx : & mut TxContext) : (TokenPolicy < T >, TokenPolicyCap < T >) { let policy = TokenPolicy { id : object :: new (ctx) , rules : vec_map :: empty () , spent_balance : balance :: zero () , } ; let cap = TokenPolicyCap { id : object :: new (ctx) , for : object :: id (& policy) , } ; (policy , cap) } # [test_only] public fun burn_policy_for_testing < T > (policy : TokenPolicy < T >, cap : TokenPolicyCap < T >) { let TokenPolicyCap { id : cap_id , for : _ } = cap ; let TokenPolicy { id , rules : _ , spent_balance } = policy ; spent_balance . destroy_for_testing () ; cap_id . delete () ; id . delete () ; } # [test_only] public fun mint_for_testing < T > (amount : u64 , ctx : & mut TxContext) : Token < T > { let balance = balance :: create_for_testing (amount) ; Token { id : object :: new (ctx) , balance } } # [test_only] public fun burn_for_testing < T > (token : Token < T >) { let Token { id , balance } = token ; balance . destroy_for_testing () ; id . delete () ; }
