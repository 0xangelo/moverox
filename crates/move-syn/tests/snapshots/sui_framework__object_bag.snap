---
source: crates/move-syn/tests/sui-framework.rs
expression: ast.tokens_to_string()
---
# [doc = " Similar to `sui::bag`, an `ObjectBag` is a heterogeneous map-like collection. But unlike"] # [doc = " `sui::bag`, the values bound to these dynamic fields _must_ be objects themselves. This allows"] # [doc = " for the objects to still exist in storage, which may be important for external tools."] # [doc = " The difference is otherwise not observable from within Move."] module sui :: object_bag ; use sui :: dynamic_object_field as ofield ; const EBagNotEmpty : u64 = 0 ; public struct ObjectBag has key , store { # [doc = " the ID of this bag"] id : UID , # [doc = " the number of key-value pairs in the bag"] size : u64 , } # [doc = " Creates a new, empty bag"] public fun new (ctx : & mut TxContext) : ObjectBag { ObjectBag { id : object :: new (ctx) , size : 0 , } } # [doc = " Adds a key-value pair to the bag `bag: &mut ObjectBag`"] # [doc = " Aborts with `sui::dynamic_field::EFieldAlreadyExists` if the bag already has an entry with"] # [doc = " that key `k: K`."] public fun add < K : copy + drop + store , V : key + store > (bag : & mut ObjectBag , k : K , v : V) { ofield :: add (& mut bag . id , k , v) ; bag . size = bag . size + 1 ; } # [syntax (index)] # [doc = " Immutably borrows the value associated with the key in the bag `bag: &ObjectBag`."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the bag does not have an entry with"] # [doc = " that key `k: K`."] # [doc = " Aborts with `sui::dynamic_field::EFieldTypeMismatch` if the bag has an entry for the key, but"] # [doc = " the value does not have the specified type."] public fun borrow < K : copy + drop + store , V : key + store > (bag : & ObjectBag , k : K) : & V { ofield :: borrow (& bag . id , k) } # [syntax (index)] # [doc = " Mutably borrows the value associated with the key in the bag `bag: &mut ObjectBag`."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the bag does not have an entry with"] # [doc = " that key `k: K`."] # [doc = " Aborts with `sui::dynamic_field::EFieldTypeMismatch` if the bag has an entry for the key, but"] # [doc = " the value does not have the specified type."] public fun borrow_mut < K : copy + drop + store , V : key + store > (bag : & mut ObjectBag , k : K) : & mut V { ofield :: borrow_mut (& mut bag . id , k) } # [doc = " Mutably borrows the key-value pair in the bag `bag: &mut ObjectBag` and returns the value."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the bag does not have an entry with"] # [doc = " that key `k: K`."] # [doc = " Aborts with `sui::dynamic_field::EFieldTypeMismatch` if the bag has an entry for the key, but"] # [doc = " the value does not have the specified type."] public fun remove < K : copy + drop + store , V : key + store > (bag : & mut ObjectBag , k : K) : V { let v = ofield :: remove (& mut bag . id , k) ; bag . size = bag . size - 1 ; v } # [doc = " Returns true iff there is an value associated with the key `k: K` in the bag `bag: &ObjectBag`"] public fun contains < K : copy + drop + store > (bag : & ObjectBag , k : K) : bool { ofield :: exists_ < K > (& bag . id , k) } # [doc = " Returns true iff there is an value associated with the key `k: K` in the bag `bag: &ObjectBag`"] # [doc = " with an assigned value of type `V`"] public fun contains_with_type < K : copy + drop + store , V : key + store > (bag : & ObjectBag , k : K) : bool { ofield :: exists_with_type < K , V > (& bag . id , k) } # [doc = " Returns the size of the bag, the number of key-value pairs"] public fun length (bag : & ObjectBag) : u64 { bag . size } # [doc = " Returns true iff the bag is empty (if `length` returns `0`)"] public fun is_empty (bag : & ObjectBag) : bool { bag . size == 0 } # [doc = " Destroys an empty bag"] # [doc = " Aborts with `EBagNotEmpty` if the bag still contains values"] public fun destroy_empty (bag : ObjectBag) { let ObjectBag { id , size } = bag ; assert ! (size == 0 , EBagNotEmpty) ; id . delete () } # [doc = " Returns the ID of the object associated with the key if the bag has an entry with key `k: K`"] # [doc = " Returns none otherwise"] public fun value_id < K : copy + drop + store > (bag : & ObjectBag , k : K) : Option < ID > { ofield :: id (& bag . id , k) }
