---
source: crates/move-syn/tests/sui-framework.rs
expression: ast.tokens_to_string()
---
# [allow (unused_const)] # [doc = " In addition to the fields declared in its type definition, a Sui object can have dynamic fields"] # [doc = " that can be added after the object has been constructed. Unlike ordinary field names"] # [doc = " (which are always statically declared identifiers) a dynamic field name can be any value with"] # [doc = " the `copy`, `drop`, and `store` abilities, e.g. an integer, a boolean, or a string."] # [doc = " This gives Sui programmers the flexibility to extend objects on-the-fly, and it also serves as a"] # [doc = " building block for core collection types"] module sui :: dynamic_field ; # [doc = " The object already has a dynamic field with this name (with the value and type specified)"] const EFieldAlreadyExists : u64 = 0 ; # [doc = " Cannot load dynamic field."] # [doc = " The object does not have a dynamic field with this name (with the value and type specified)"] const EFieldDoesNotExist : u64 = 1 ; # [doc = " The object has a field with that name, but the value type does not match"] const EFieldTypeMismatch : u64 = 2 ; # [doc = " Failed to serialize the field's name"] const EBCSSerializationFailure : u64 = 3 ; # [doc = " The object added as a dynamic field was previously a shared object"] const ESharedObjectOperationNotSupported : u64 = 4 ; # [doc = " Internal object used for storing the field and value"] public struct Field < Name : copy + drop + store , Value : store > has key { # [doc = " Determined by the hash of the object ID, the field name value and it's type,"] # [doc = " i.e. hash(parent.id || name || Name)"] id : UID , # [doc = " The value for the name of this field"] name : Name , # [doc = " The value bound to this field"] value : Value , } # [doc = " Adds a dynamic field to the object `object: &mut UID` at field specified by `name: Name`."] # [doc = " Aborts with `EFieldAlreadyExists` if the object already has that field with that name."] public fun add < Name : copy + drop + store , Value : store > (object : & mut UID , name : Name , value : Value ,) { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; assert ! (! has_child_object (object_addr , hash) , EFieldAlreadyExists) ; let field = Field { id : object :: new_uid_from_hash (hash) , name , value , } ; add_child_object (object_addr , field) } # [doc = " Immutably borrows the `object`s dynamic field with the name specified by `name: Name`."] # [doc = " Aborts with `EFieldDoesNotExist` if the object does not have a field with that name."] # [doc = " Aborts with `EFieldTypeMismatch` if the field exists, but the value does not have the specified"] # [doc = " type."] public fun borrow < Name : copy + drop + store , Value : store > (object : & UID , name : Name) : & Value { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; let field = borrow_child_object < Field < Name , Value >> (object , hash) ; & field . value } # [doc = " Mutably borrows the `object`s dynamic field with the name specified by `name: Name`."] # [doc = " Aborts with `EFieldDoesNotExist` if the object does not have a field with that name."] # [doc = " Aborts with `EFieldTypeMismatch` if the field exists, but the value does not have the specified"] # [doc = " type."] public fun borrow_mut < Name : copy + drop + store , Value : store > (object : & mut UID , name : Name ,) : & mut Value { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; let field = borrow_child_object_mut < Field < Name , Value >> (object , hash) ; & mut field . value } # [doc = " Removes the `object`s dynamic field with the name specified by `name: Name` and returns the"] # [doc = " bound value."] # [doc = " Aborts with `EFieldDoesNotExist` if the object does not have a field with that name."] # [doc = " Aborts with `EFieldTypeMismatch` if the field exists, but the value does not have the specified"] # [doc = " type."] public fun remove < Name : copy + drop + store , Value : store > (object : & mut UID , name : Name) : Value { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; let Field { id , name : _ , value } = remove_child_object < Field < Name , Value >> (object_addr , hash) ; id . delete () ; value } # [doc = " Returns true if and only if the `object` has a dynamic field with the name specified by"] # [doc = " `name: Name` but without specifying the `Value` type"] public fun exists_ < Name : copy + drop + store > (object : & UID , name : Name) : bool { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; has_child_object (object_addr , hash) } # [doc = " Removes the dynamic field if it exists. Returns the `some(Value)` if it exists or none otherwise."] public fun remove_if_exists < Name : copy + drop + store , Value : store > (object : & mut UID , name : Name ,) : Option < Value > { if (exists_ < Name > (object , name)) { option :: some (remove (object , name)) } else { option :: none () } } # [doc = " Returns true if and only if the `object` has a dynamic field with the name specified by"] # [doc = " `name: Name` with an assigned value of type `Value`."] public fun exists_with_type < Name : copy + drop + store , Value : store > (object : & UID , name : Name ,) : bool { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; has_child_object_with_ty < Field < Name , Value >> (object_addr , hash) } public (package) fun field_info < Name : copy + drop + store > (object : & UID , name : Name ,) : (& UID , address) { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; let Field { id , name : _ , value } = borrow_child_object < Field < Name , ID >> (object , hash) ; (id , value . to_address ()) } public (package) fun field_info_mut < Name : copy + drop + store > (object : & mut UID , name : Name ,) : (& mut UID , address) { let object_addr = object . to_address () ; let hash = hash_type_and_key (object_addr , name) ; let Field { id , name : _ , value } = borrow_child_object_mut < Field < Name , ID >> (object , hash) ; (id , value . to_address ()) } # [doc = " May abort with `EBCSSerializationFailure`."] public (package) native fun hash_type_and_key < K : copy + drop + store > (parent : address , k : K ,) : address ; public (package) native fun add_child_object < Child : key > (parent : address , child : Child) ; # [doc = " throws `EFieldDoesNotExist` if a child does not exist with that ID"] # [doc = " or throws `EFieldTypeMismatch` if the type does not match,"] # [doc = " and may also abort with `EBCSSerializationFailure`"] # [doc = " we need two versions to return a reference or a mutable reference"] public (package) native fun borrow_child_object < Child : key > (object : & UID , id : address) : & Child ; public (package) native fun borrow_child_object_mut < Child : key > (object : & mut UID , id : address ,) : & mut Child ; # [doc = " throws `EFieldDoesNotExist` if a child does not exist with that ID"] # [doc = " or throws `EFieldTypeMismatch` if the type does not match,"] # [doc = " and may also abort with `EBCSSerializationFailure`."] public (package) native fun remove_child_object < Child : key > (parent : address , id : address) : Child ; public (package) native fun has_child_object (parent : address , id : address) : bool ; public (package) native fun has_child_object_with_ty < Child : key > (parent : address , id : address) : bool ;
