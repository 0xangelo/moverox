---
source: crates/move-syn/tests/sui-framework.rs
expression: ast.tokens_to_string()
---
# [doc = " A table is a map-like collection. But unlike a traditional collection, it's keys and values are"] # [doc = " not stored within the `Table` value, but instead are stored using Sui's object system. The"] # [doc = " `Table` struct acts only as a handle into the object system to retrieve those keys and values."] # [doc = " Note that this means that `Table` values with exactly the same key-value mapping will not be"] # [doc = " equal, with `==`, at runtime. For example"] # [doc = " ```"] # [doc = " let table1 = table::new<u64, bool>();"] # [doc = " let table2 = table::new<u64, bool>();"] # [doc = " table::add(&mut table1, 0, false);"] # [doc = " table::add(&mut table1, 1, true);"] # [doc = " table::add(&mut table2, 0, false);"] # [doc = " table::add(&mut table2, 1, true);"] # [doc = " // table1 does not equal table2, despite having the same entries"] # [doc = " assert!(&table1 != &table2);"] # [doc = " ```"] module sui :: table ; use sui :: dynamic_field as field ; const ETableNotEmpty : u64 = 0 ; public struct Table < phantom K : copy + drop + store , phantom V : store > has key , store { # [doc = " the ID of this table"] id : UID , # [doc = " the number of key-value pairs in the table"] size : u64 , } # [doc = " Creates a new, empty table"] public fun new < K : copy + drop + store , V : store > (ctx : & mut TxContext) : Table < K , V > { Table { id : object :: new (ctx) , size : 0 , } } # [doc = " Adds a key-value pair to the table `table: &mut Table<K, V>`"] # [doc = " Aborts with `sui::dynamic_field::EFieldAlreadyExists` if the table already has an entry with"] # [doc = " that key `k: K`."] public fun add < K : copy + drop + store , V : store > (table : & mut Table < K , V >, k : K , v : V) { field :: add (& mut table . id , k , v) ; table . size = table . size + 1 ; } # [syntax (index)] # [doc = " Immutable borrows the value associated with the key in the table `table: &Table<K, V>`."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the table does not have an entry with"] # [doc = " that key `k: K`."] public fun borrow < K : copy + drop + store , V : store > (table : & Table < K , V >, k : K) : & V { field :: borrow (& table . id , k) } # [syntax (index)] # [doc = " Mutably borrows the value associated with the key in the table `table: &mut Table<K, V>`."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the table does not have an entry with"] # [doc = " that key `k: K`."] public fun borrow_mut < K : copy + drop + store , V : store > (table : & mut Table < K , V >, k : K) : & mut V { field :: borrow_mut (& mut table . id , k) } # [doc = " Removes the key-value pair in the table `table: &mut Table<K, V>` and returns the value."] # [doc = " Aborts with `sui::dynamic_field::EFieldDoesNotExist` if the table does not have an entry with"] # [doc = " that key `k: K`."] public fun remove < K : copy + drop + store , V : store > (table : & mut Table < K , V >, k : K) : V { let v = field :: remove (& mut table . id , k) ; table . size = table . size - 1 ; v } # [doc = " Returns true if there is a value associated with the key `k: K` in table `table: &Table<K, V>`"] public fun contains < K : copy + drop + store , V : store > (table : & Table < K , V >, k : K) : bool { field :: exists_with_type < K , V > (& table . id , k) } # [doc = " Returns the size of the table, the number of key-value pairs"] public fun length < K : copy + drop + store , V : store > (table : & Table < K , V >) : u64 { table . size } # [doc = " Returns true if the table is empty (if `length` returns `0`)"] public fun is_empty < K : copy + drop + store , V : store > (table : & Table < K , V >) : bool { table . size == 0 } # [doc = " Destroys an empty table"] # [doc = " Aborts with `ETableNotEmpty` if the table still contains values"] public fun destroy_empty < K : copy + drop + store , V : store > (table : Table < K , V >) { let Table { id , size } = table ; assert ! (size == 0 , ETableNotEmpty) ; id . delete () } # [doc = " Drop a possibly non-empty table."] # [doc = " Usable only if the value type `V` has the `drop` ability"] public fun drop < K : copy + drop + store , V : drop + store > (table : Table < K , V >) { let Table { id , size : _ } = table ; id . delete () }
