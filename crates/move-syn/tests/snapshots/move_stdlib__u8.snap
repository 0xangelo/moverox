---
source: crates/move-syn/tests/move-stdlib.rs
expression: ast.tokens_to_string()
---
# [defines_primitive (u8)] module std :: u8 ; use std :: string :: String ; # [doc = " Returns the bitwise not of the value."] # [doc = " Each bit that is 1 becomes 0. Each bit that is 0 becomes 1."] public fun bitwise_not (x : u8) : u8 { x ^ max_value ! () } # [doc = " Return the larger of `x` and `y`"] public fun max (x : u8 , y : u8) : u8 { std :: macros :: num_max ! (x , y) } # [doc = " Return the smaller of `x` and `y`"] public fun min (x : u8 , y : u8) : u8 { std :: macros :: num_min ! (x , y) } # [doc = " Return the absolute value of x - y"] public fun diff (x : u8 , y : u8) : u8 { std :: macros :: num_diff ! (x , y) } # [doc = " Calculate x / y, but round up the result."] public fun divide_and_round_up (x : u8 , y : u8) : u8 { std :: macros :: num_divide_and_round_up ! (x , y) } # [doc = " Return the value of a base raised to a power"] public fun pow (base : u8 , exponent : u8) : u8 { std :: macros :: num_pow ! (base , exponent) } # [doc = " Get a nearest lower integer Square Root for `x`. Given that this"] # [doc = " function can only operate with integers, it is impossible"] # [doc = " to get perfect (or precise) integer square root for some numbers."] # [doc = ""] # [doc = " Example:"] # [doc = " ```"] # [doc = " math::sqrt(9) => 3"] # [doc = " math::sqrt(8) => 2 // the nearest lower square root is 4;"] # [doc = " ```"] # [doc = ""] # [doc = " In integer math, one of the possible ways to get results with more"] # [doc = " precision is to use higher values or temporarily multiply the"] # [doc = " value by some bigger number. Ideally if this is a square of 10 or 100."] # [doc = ""] # [doc = " Example:"] # [doc = " ```"] # [doc = " math::sqrt(8) => 2;"] # [doc = " math::sqrt(8 * 10000) => 282;"] # [doc = " // now we can use this value as if it was 2.82;"] # [doc = " // but to get the actual result, this value needs"] # [doc = " // to be divided by 100 (because sqrt(10000))."] # [doc = ""] # [doc = ""] # [doc = " math::sqrt(8 * 1000000) => 2828; // same as above, 2828 / 1000 (2.828)"] # [doc = " ```"] public fun sqrt (x : u8) : u8 { std :: macros :: num_sqrt !< u8 , u16 > (x , 8) } public fun to_string (x : u8) : String { std :: macros :: num_to_string ! (x) } # [doc = " Maximum value for a `u8`"] public macro fun max_value () : u8 { 0xFF } # [doc = " Loops applying `$f` to each number from `$start` to `$stop` (exclusive)"] public macro fun range_do < $ R : drop > ($ start : u8 , $ stop : u8 , $ f : | u8 | -> $ R) { std :: macros :: range_do ! ($ start , $ stop , $ f) } # [doc = " Loops applying `$f` to each number from `$start` to `$stop` (inclusive)"] public macro fun range_do_eq < $ R : drop > ($ start : u8 , $ stop : u8 , $ f : | u8 | -> $ R) { std :: macros :: range_do_eq ! ($ start , $ stop , $ f) } # [doc = " Loops applying `$f` to each number from `0` to `$stop` (exclusive)"] public macro fun do < $ R : drop > ($ stop : u8 , $ f : | u8 | -> $ R) { std :: macros :: do ! ($ stop , $ f) } # [doc = " Loops applying `$f` to each number from `0` to `$stop` (inclusive)"] public macro fun do_eq < $ R : drop > ($ stop : u8 , $ f : | u8 | -> $ R) { std :: macros :: do_eq ! ($ stop , $ f) }
