---
source: crates/move-syn/tests/sui-framework.rs
expression: ast.tokens_to_string()
---
# [doc = " This module provides functionality for generating secure randomness."] module sui :: random ; use std :: bcs ; use sui :: hmac :: hmac_sha3_256 ; use sui :: versioned :: { Self , Versioned } ; const ENotSystemAddress : u64 = 0 ; const EWrongInnerVersion : u64 = 1 ; const EInvalidRandomnessUpdate : u64 = 2 ; const EInvalidRange : u64 = 3 ; const EInvalidLength : u64 = 4 ; const CURRENT_VERSION : u64 = 1 ; const RAND_OUTPUT_LEN : u16 = 32 ; const U16_MAX : u64 = 0xFFFF ; # [doc = " Singleton shared object which stores the global randomness state."] # [doc = " The actual state is stored in a versioned inner field."] public struct Random has key { id : UID , inner : Versioned , } public struct RandomInner has store { version : u64 , epoch : u64 , randomness_round : u64 , random_bytes : vector < u8 > , } # [allow (unused_function)] # [doc = " Create and share the Random object. This function is called exactly once, when"] # [doc = " the Random object is first created."] # [doc = " Can only be called by genesis or change_epoch transactions."] fun create (ctx : & mut TxContext) { assert ! (ctx . sender () == @ 0x0 , ENotSystemAddress) ; let version = CURRENT_VERSION ; let inner = RandomInner { version , epoch : ctx . epoch () , randomness_round : 0 , random_bytes : vector [] , } ; let self = Random { id : object :: randomness_state () , inner : versioned :: create (version , inner , ctx) , } ; transfer :: share_object (self) ; } # [test_only] public fun create_for_testing (ctx : & mut TxContext) { create (ctx) ; } fun load_inner_mut (self : & mut Random) : & mut RandomInner { let version = versioned :: version (& self . inner) ; assert ! (version == CURRENT_VERSION , EWrongInnerVersion) ; let inner : & mut RandomInner = self . inner . load_value_mut () ; assert ! (inner . version == version , EWrongInnerVersion) ; inner } fun load_inner (self : & Random) : & RandomInner { let version = self . inner . version () ; assert ! (version == CURRENT_VERSION , EWrongInnerVersion) ; let inner : & RandomInner = self . inner . load_value () ; assert ! (inner . version == version , EWrongInnerVersion) ; inner } # [allow (unused_function)] # [doc = " Record new randomness. Called when executing the RandomnessStateUpdate system"] # [doc = " transaction."] fun update_randomness_state (self : & mut Random , new_round : u64 , new_bytes : vector < u8 >, ctx : & TxContext ,) { assert ! (ctx . sender () == @ 0x0 , ENotSystemAddress) ; let epoch = ctx . epoch () ; let inner = self . load_inner_mut () ; if (inner . randomness_round == 0 && inner . epoch == 0 && inner . random_bytes . is_empty ()) { assert ! (new_round == 0 , EInvalidRandomnessUpdate) ; } else { assert ! ((epoch > inner . epoch && new_round == 0) || (new_round == inner . randomness_round + 1) , EInvalidRandomnessUpdate ,) ; } ; inner . epoch = ctx . epoch () ; inner . randomness_round = new_round ; inner . random_bytes = new_bytes ; } # [test_only] public fun update_randomness_state_for_testing (self : & mut Random , new_round : u64 , new_bytes : vector < u8 >, ctx : & TxContext ,) { self . update_randomness_state (new_round , new_bytes , ctx) ; } # [doc = " Unique randomness generator, derived from the global randomness."] public struct RandomGenerator has drop { seed : vector < u8 > , counter : u16 , buffer : vector < u8 > , } # [doc = " Create a generator. Can be used to derive up to MAX_U16 * 32 random bytes."] # [doc = ""] # [doc = " Using randomness can be error-prone if you don't observe the subtleties in its correct use, for example, randomness"] # [doc = " dependent code might be exploitable to attacks that carefully set the gas budget"] # [doc = " in a way that breaks security. For more information, see:"] # [doc = " https://docs.sui.io/guides/developer/advanced/randomness-onchain"] public fun new_generator (r : & Random , ctx : & mut TxContext) : RandomGenerator { let inner = r . load_inner () ; let seed = hmac_sha3_256 (& inner . random_bytes , & ctx . fresh_object_address () . to_bytes () ,) ; RandomGenerator { seed , counter : 0 , buffer : vector [] } } # [doc = " Get the next block of 32 random bytes."] fun derive_next_block (g : & mut RandomGenerator) : vector < u8 > { g . counter = g . counter + 1 ; hmac_sha3_256 (& g . seed , & bcs :: to_bytes (& g . counter)) } # [doc = " Generate n random bytes."] public fun generate_bytes (g : & mut RandomGenerator , num_of_bytes : u16) : vector < u8 > { let mut result = vector [] ; let num_of_blocks = num_of_bytes / RAND_OUTPUT_LEN ; num_of_blocks . do ! (| _ | result . append (g . derive_next_block ())) ; let num_of_bytes = num_of_bytes as u64 ; let remaining = num_of_bytes - result . length () ; if (g . buffer . length () < remaining) { let next_block = g . derive_next_block () ; g . buffer . append (next_block) ; } ; remaining . do ! (| _ | result . push_back (g . buffer . pop_back ())) ; result } macro fun uint_from_bytes < $ T : drop > ($ g : & mut RandomGenerator , $ num_of_bytes : u8) : $ T { let g = $ g ; let num_of_bytes = $ num_of_bytes ; if (g . buffer . length () < num_of_bytes as u64) { let next_block = g . derive_next_block () ; g . buffer . append (next_block) ; } ; let mut result : u256 = 0 ; num_of_bytes . do ! (| _ | { let byte = g . buffer . pop_back () as u256 ; result = (result << 8) + byte ; }) ; result as $ T } # [doc = " Generate a u256."] public fun generate_u256 (g : & mut RandomGenerator) : u256 { uint_from_bytes ! (g , 32) } # [doc = " Generate a u128."] public fun generate_u128 (g : & mut RandomGenerator) : u128 { uint_from_bytes ! (g , 16) } # [doc = " Generate a u64."] public fun generate_u64 (g : & mut RandomGenerator) : u64 { uint_from_bytes ! (g , 8) } # [doc = " Generate a u32."] public fun generate_u32 (g : & mut RandomGenerator) : u32 { uint_from_bytes ! (g , 4) } # [doc = " Generate a u16."] public fun generate_u16 (g : & mut RandomGenerator) : u16 { uint_from_bytes ! (g , 2) } # [doc = " Generate a u8."] public fun generate_u8 (g : & mut RandomGenerator) : u8 { uint_from_bytes ! (g , 1) } # [doc = " Generate a boolean."] public fun generate_bool (g : & mut RandomGenerator) : bool { (uint_from_bytes ! (g , 1) & 1) == 1 } # [doc = " Helper macro to generate a random uint in [min, max] using a random number with num_of_bytes bytes."] # [doc = " Assumes that the caller verified the inputs, and uses num_of_bytes to control the bias (e.g., 8 bytes larger"] # [doc = " than the actual type used by the caller function to limit the bias by 2^{-64})."] macro fun uint_in_range < $ T : drop > ($ g : & mut RandomGenerator , $ min : $ T , $ max : $ T , $ num_of_bytes : u8 ,) : $ T { let min = $ min ; let max = $ max ; assert ! (min <= max , EInvalidRange) ; if (min == max) return min ; let range_size = (max - min) as u256 + 1 ; let rand = uint_from_bytes ! ($ g , $ num_of_bytes) ; min + (rand % range_size as $ T) } # [doc = " Generate a random u128 in [min, max] (with a bias of 2^{-64})."] public fun generate_u128_in_range (g : & mut RandomGenerator , min : u128 , max : u128) : u128 { uint_in_range ! (g , min , max , 24) } public fun generate_u64_in_range (g : & mut RandomGenerator , min : u64 , max : u64) : u64 { uint_in_range ! (g , min , max , 16) } # [doc = " Generate a random u32 in [min, max] (with a bias of 2^{-64})."] public fun generate_u32_in_range (g : & mut RandomGenerator , min : u32 , max : u32) : u32 { uint_in_range ! (g , min , max , 12) } # [doc = " Generate a random u16 in [min, max] (with a bias of 2^{-64})."] public fun generate_u16_in_range (g : & mut RandomGenerator , min : u16 , max : u16) : u16 { uint_in_range ! (g , min , max , 10) } # [doc = " Generate a random u8 in [min, max] (with a bias of 2^{-64})."] public fun generate_u8_in_range (g : & mut RandomGenerator , min : u8 , max : u8) : u8 { uint_in_range ! (g , min , max , 9) } # [doc = " Shuffle a vector using the random generator (Fisherâ€“Yates/Knuth shuffle)."] public fun shuffle < T > (g : & mut RandomGenerator , v : & mut vector < T >) { let n = v . length () ; if (n == 0) return ; assert ! (n <= U16_MAX , EInvalidLength) ; let n = n as u16 ; let end = n - 1 ; end . do ! (| i | { let j = g . generate_u16_in_range (i , end) ; v . swap (i as u64 , j as u64) ; }) ; } # [test_only] public fun generator_seed (r : & RandomGenerator) : & vector < u8 > { & r . seed } # [test_only] public fun generator_counter (r : & RandomGenerator) : u16 { r . counter } # [test_only] public fun generator_buffer (r : & RandomGenerator) : & vector < u8 > { & r . buffer } # [test_only] # [doc = " Random generator from a non-deterministic seed."] # [doc = " To be used when non-deterministic randomness is needed in tests (e.g., fuzzing)."] public fun new_generator_for_testing () : RandomGenerator { let seed = generate_rand_seed_for_testing () ; new_generator_from_seed_for_testing (seed) } # [test_only] # [doc = " Random generator from a given seed."] public fun new_generator_from_seed_for_testing (seed : vector < u8 >) : RandomGenerator { RandomGenerator { seed , counter : 0 , buffer : vector [] } } # [test_only] native fun generate_rand_seed_for_testing () : vector < u8 > ;
